{
  "metadata": [
    {
      "name": "System",
      "prefix": "System",
      "calls": [
        {
          "name": "fill_block",
          "args": [
            {
              "name": "_ratio",
              "type": "Perbill"
            }
          ],
          "docs": [
            " A dispatch that will fill the block weight up to the given ratio."
          ],
          "look_up": "0000"
        },
        {
          "name": "remark",
          "args": [
            {
              "name": "_remark",
              "type": "Vec<u8>"
            }
          ],
          "docs": [
            " Make some on-chain remark.",
            "",
            " # <weight>",
            " - `O(1)`",
            " - Base Weight: 0.665 \u00b5s, independent of remark length.",
            " - No DB operations.",
            " # <\/weight>"
          ],
          "look_up": "0001"
        },
        {
          "name": "set_heap_pages",
          "args": [
            {
              "name": "pages",
              "type": "u64"
            }
          ],
          "docs": [
            " Set the number of pages in the WebAssembly environment's heap.",
            "",
            " # <weight>",
            " - `O(1)`",
            " - 1 storage write.",
            " - Base Weight: 1.405 \u00b5s",
            " - 1 write to HEAP_PAGES",
            " # <\/weight>"
          ],
          "look_up": "0002"
        },
        {
          "name": "set_code",
          "args": [
            {
              "name": "code",
              "type": "Vec<u8>"
            }
          ],
          "docs": [
            " Set the new runtime code.",
            "",
            " # <weight>",
            " - `O(C + S)` where `C` length of `code` and `S` complexity of `can_set_code`",
            " - 1 storage write (codec `O(C)`).",
            " - 1 call to `can_set_code`: `O(S)` (calls `sp_io::misc::runtime_version` which is expensive).",
            " - 1 event.",
            " The weight of this function is dependent on the runtime, but generally this is very expensive.",
            " We will treat this as a full block.",
            " # <\/weight>"
          ],
          "look_up": "0003"
        },
        {
          "name": "set_code_without_checks",
          "args": [
            {
              "name": "code",
              "type": "Vec<u8>"
            }
          ],
          "docs": [
            " Set the new runtime code without doing any checks of the given `code`.",
            "",
            " # <weight>",
            " - `O(C)` where `C` length of `code`",
            " - 1 storage write (codec `O(C)`).",
            " - 1 event.",
            " The weight of this function is dependent on the runtime. We will treat this as a full block.",
            " # <\/weight>"
          ],
          "look_up": "0004"
        },
        {
          "name": "set_changes_trie_config",
          "args": [
            {
              "name": "changes_trie_config",
              "type": "Option<ChangesTrieConfiguration>"
            }
          ],
          "docs": [
            " Set the new changes trie configuration.",
            "",
            " # <weight>",
            " - `O(1)`",
            " - 1 storage write or delete (codec `O(1)`).",
            " - 1 call to `deposit_log`: Uses `append` API, so O(1)",
            " - Base Weight: 7.218 \u00b5s",
            " - DB Weight:",
            "     - Writes: Changes Trie, System Digest",
            " # <\/weight>"
          ],
          "look_up": "0005"
        },
        {
          "name": "set_storage",
          "args": [
            {
              "name": "items",
              "type": "Vec<KeyValue>"
            }
          ],
          "docs": [
            " Set some items of storage.",
            "",
            " # <weight>",
            " - `O(I)` where `I` length of `items`",
            " - `I` storage writes (`O(1)`).",
            " - Base Weight: 0.568 * i \u00b5s",
            " - Writes: Number of items",
            " # <\/weight>"
          ],
          "look_up": "0006"
        },
        {
          "name": "kill_storage",
          "args": [
            {
              "name": "keys",
              "type": "Vec<Key>"
            }
          ],
          "docs": [
            " Kill some items from storage.",
            "",
            " # <weight>",
            " - `O(IK)` where `I` length of `keys` and `K` length of one key",
            " - `I` storage deletions.",
            " - Base Weight: .378 * i \u00b5s",
            " - Writes: Number of items",
            " # <\/weight>"
          ],
          "look_up": "0007"
        },
        {
          "name": "kill_prefix",
          "args": [
            {
              "name": "prefix",
              "type": "Key"
            },
            {
              "name": "_subkeys",
              "type": "u32"
            }
          ],
          "docs": [
            " Kill all storage items with a key that starts with the given prefix.",
            "",
            " **NOTE:** We rely on the Root origin to provide us the number of subkeys under",
            " the prefix we are removing to accurately calculate the weight of this function.",
            "",
            " # <weight>",
            " - `O(P)` where `P` amount of keys with prefix `prefix`",
            " - `P` storage deletions.",
            " - Base Weight: 0.834 * P \u00b5s",
            " - Writes: Number of subkeys + 1",
            " # <\/weight>"
          ],
          "look_up": "0008"
        },
        {
          "name": "suicide",
          "args": [],
          "docs": [
            " Kill the sending account, assuming there are no references outstanding and the composite",
            " data is equal to its default value.",
            "",
            " # <weight>",
            " - `O(1)`",
            " - 1 storage read and deletion.",
            " --------------------",
            " Base Weight: 8.626 \u00b5s",
            " No DB Read or Write operations because caller is already in overlay",
            " # <\/weight>"
          ],
          "look_up": "0009"
        }
      ],
      "events": [
        {
          "name": "ExtrinsicSuccess",
          "args": [
            "DispatchInfo"
          ],
          "docs": [
            " An extrinsic completed successfully. [info]"
          ],
          "look_up": "0000"
        },
        {
          "name": "ExtrinsicFailed",
          "args": [
            "DispatchError",
            "DispatchInfo"
          ],
          "docs": [
            " An extrinsic failed. [error, info]"
          ],
          "look_up": "0001"
        },
        {
          "name": "CodeUpdated",
          "args": [],
          "docs": [
            " `:code` was updated."
          ],
          "look_up": "0002"
        },
        {
          "name": "NewAccount",
          "args": [
            "AccountId"
          ],
          "docs": [
            " A new [account] was created."
          ],
          "look_up": "0003"
        },
        {
          "name": "KilledAccount",
          "args": [
            "AccountId"
          ],
          "docs": [
            " An [account] was reaped."
          ],
          "look_up": "0004"
        }
      ],
      "errors": [
        {
          "name": "InvalidSpecName",
          "docs": [
            " The name of specification does not match between the current runtime",
            " and the new runtime."
          ]
        },
        {
          "name": "SpecVersionNeedsToIncrease",
          "docs": [
            " The specification version is not allowed to decrease between the current runtime",
            " and the new runtime."
          ]
        },
        {
          "name": "FailedToExtractRuntimeVersion",
          "docs": [
            " Failed to extract the runtime version from the new runtime.",
            "",
            " Either calling `Core_version` or decoding `RuntimeVersion` failed."
          ]
        },
        {
          "name": "NonDefaultComposite",
          "docs": [
            " Suicide called when the account has non-default composite data."
          ]
        },
        {
          "name": "NonZeroRefCount",
          "docs": [
            " There is a non-zero reference count preventing the account from being purged."
          ]
        }
      ],
      "constants": [
        {
          "name": "BlockHashCount",
          "type": "T::BlockNumber",
          "value": "60090000",
          "docs": [
            " The maximum number of blocks to allow in mortal eras."
          ]
        },
        {
          "name": "MaximumBlockWeight",
          "type": "Weight",
          "value": "00204aa9d1010000",
          "docs": [
            " The maximum weight of a block."
          ]
        },
        {
          "name": "DbWeight",
          "type": "RuntimeDbWeight",
          "value": "40787d010000000000e1f50500000000",
          "docs": [
            " The weight of runtime database operations the runtime can invoke."
          ]
        },
        {
          "name": "BlockExecutionWeight",
          "type": "Weight",
          "value": "00f2052a01000000",
          "docs": [
            " The base weight of executing a block, independent of the transactions in the block."
          ]
        },
        {
          "name": "ExtrinsicBaseWeight",
          "type": "Weight",
          "value": "4059730700000000",
          "docs": [
            " The base weight of an Extrinsic in the block, independent of the of extrinsic being executed."
          ]
        },
        {
          "name": "MaximumBlockLength",
          "type": "u32",
          "value": "00005000",
          "docs": [
            " The maximum length of a block (in bytes)."
          ]
        }
      ],
      "index": 0
    },
    {
      "name": "Utility",
      "prefix": "System",
      "calls": [
        {
          "name": "batch",
          "args": [
            {
              "name": "calls",
              "type": "Vec<<T as Trait>::Call>"
            }
          ],
          "docs": [
            " Send a batch of dispatch calls.",
            "",
            " May be called from any origin.",
            "",
            " - `calls`: The calls to be dispatched from the same origin.",
            "",
            " If origin is root then call are dispatch without checking origin filter. (This includes",
            " bypassing `frame_system::Trait::BaseCallFilter`).",
            "",
            " # <weight>",
            " - Base weight: 14.39 + .987 * c \u00b5s",
            " - Plus the sum of the weights of the `calls`.",
            " - Plus one additional event. (repeat read\/write)",
            " # <\/weight>",
            "",
            " This will return `Ok` in all circumstances. To determine the success of the batch, an",
            " event is deposited. If a call failed and the batch was interrupted, then the",
            " `BatchInterrupted` event is deposited, along with the number of successful calls made",
            " and the error of the failed call. If all were successful, then the `BatchCompleted`",
            " event is deposited."
          ],
          "look_up": "0100"
        },
        {
          "name": "as_derivative",
          "args": [
            {
              "name": "index",
              "type": "u16"
            },
            {
              "name": "call",
              "type": "Box<<T as Trait>::Call>"
            }
          ],
          "docs": [
            " Send a call through an indexed pseudonym of the sender.",
            "",
            " Filter from origin are passed along. The call will be dispatched with an origin which",
            " use the same filter as the origin of this call.",
            "",
            " NOTE: If you need to ensure that any account-based filtering is not honored (i.e.",
            " because you expect `proxy` to have been used prior in the call stack and you do not want",
            " the call restrictions to apply to any sub-accounts), then use `as_multi_threshold_1`",
            " in the Multisig pallet instead.",
            "",
            " NOTE: Prior to version *12, this was called `as_limited_sub`.",
            "",
            " The dispatch origin for this call must be _Signed_."
          ],
          "look_up": "0101"
        }
      ],
      "events": [
        {
          "name": "BatchInterrupted",
          "args": [
            "u32",
            "DispatchError"
          ],
          "docs": [
            " Batch of dispatches did not complete fully. Index of first failing dispatch given, as",
            " well as the error. [index, error]"
          ],
          "look_up": "0100"
        },
        {
          "name": "BatchCompleted",
          "args": [],
          "docs": [
            " Batch of dispatches completed fully with no error."
          ],
          "look_up": "0101"
        }
      ],
      "errors": [
        {
          "name": "InvalidSpecName",
          "docs": [
            " The name of specification does not match between the current runtime",
            " and the new runtime."
          ]
        },
        {
          "name": "SpecVersionNeedsToIncrease",
          "docs": [
            " The specification version is not allowed to decrease between the current runtime",
            " and the new runtime."
          ]
        },
        {
          "name": "FailedToExtractRuntimeVersion",
          "docs": [
            " Failed to extract the runtime version from the new runtime.",
            "",
            " Either calling `Core_version` or decoding `RuntimeVersion` failed."
          ]
        },
        {
          "name": "NonDefaultComposite",
          "docs": [
            " Suicide called when the account has non-default composite data."
          ]
        },
        {
          "name": "NonZeroRefCount",
          "docs": [
            " There is a non-zero reference count preventing the account from being purged."
          ]
        }
      ],
      "constants": [
        {
          "name": "BlockHashCount",
          "type": "T::BlockNumber",
          "value": "60090000",
          "docs": [
            " The maximum number of blocks to allow in mortal eras."
          ]
        },
        {
          "name": "MaximumBlockWeight",
          "type": "Weight",
          "value": "00204aa9d1010000",
          "docs": [
            " The maximum weight of a block."
          ]
        },
        {
          "name": "DbWeight",
          "type": "RuntimeDbWeight",
          "value": "40787d010000000000e1f50500000000",
          "docs": [
            " The weight of runtime database operations the runtime can invoke."
          ]
        },
        {
          "name": "BlockExecutionWeight",
          "type": "Weight",
          "value": "00f2052a01000000",
          "docs": [
            " The base weight of executing a block, independent of the transactions in the block."
          ]
        },
        {
          "name": "ExtrinsicBaseWeight",
          "type": "Weight",
          "value": "4059730700000000",
          "docs": [
            " The base weight of an Extrinsic in the block, independent of the of extrinsic being executed."
          ]
        },
        {
          "name": "MaximumBlockLength",
          "type": "u32",
          "value": "00005000",
          "docs": [
            " The maximum length of a block (in bytes)."
          ]
        }
      ],
      "index": 1
    },
    {
      "name": "Babe",
      "prefix": "Babe",
      "calls": [
        {
          "name": "report_equivocation",
          "args": [
            {
              "name": "equivocation_proof",
              "type": "EquivocationProof<T::Header>"
            },
            {
              "name": "key_owner_proof",
              "type": "T::KeyOwnerProof"
            }
          ],
          "docs": [
            " Report authority equivocation\/misbehavior. This method will verify",
            " the equivocation proof and validate the given key ownership proof",
            " against the extracted offender. If both are valid, the offence will",
            " be reported."
          ],
          "look_up": "0200"
        },
        {
          "name": "report_equivocation_unsigned",
          "args": [
            {
              "name": "equivocation_proof",
              "type": "EquivocationProof<T::Header>"
            },
            {
              "name": "key_owner_proof",
              "type": "T::KeyOwnerProof"
            }
          ],
          "docs": [
            " Report authority equivocation\/misbehavior. This method will verify",
            " the equivocation proof and validate the given key ownership proof",
            " against the extracted offender. If both are valid, the offence will",
            " be reported.",
            " This extrinsic must be called unsigned and it is expected that only",
            " block authors will call it (validated in `ValidateUnsigned`), as such",
            " if the block author is defined it will be defined as the equivocation",
            " reporter."
          ],
          "look_up": "0201"
        }
      ],
      "events": [
        {
          "name": "BatchInterrupted",
          "args": [
            "u32",
            "DispatchError"
          ],
          "docs": [
            " Batch of dispatches did not complete fully. Index of first failing dispatch given, as",
            " well as the error. [index, error]"
          ],
          "look_up": "0200"
        },
        {
          "name": "BatchCompleted",
          "args": [],
          "docs": [
            " Batch of dispatches completed fully with no error."
          ],
          "look_up": "0201"
        }
      ],
      "errors": [
        {
          "name": "InvalidSpecName",
          "docs": [
            " The name of specification does not match between the current runtime",
            " and the new runtime."
          ]
        },
        {
          "name": "SpecVersionNeedsToIncrease",
          "docs": [
            " The specification version is not allowed to decrease between the current runtime",
            " and the new runtime."
          ]
        },
        {
          "name": "FailedToExtractRuntimeVersion",
          "docs": [
            " Failed to extract the runtime version from the new runtime.",
            "",
            " Either calling `Core_version` or decoding `RuntimeVersion` failed."
          ]
        },
        {
          "name": "NonDefaultComposite",
          "docs": [
            " Suicide called when the account has non-default composite data."
          ]
        },
        {
          "name": "NonZeroRefCount",
          "docs": [
            " There is a non-zero reference count preventing the account from being purged."
          ]
        }
      ],
      "constants": [
        {
          "name": "EpochDuration",
          "type": "u64",
          "value": "c800000000000000",
          "docs": [
            " The number of **slots** that an epoch takes. We couple sessions to",
            " epochs, i.e. we start a new session once the new epoch begins."
          ]
        },
        {
          "name": "ExpectedBlockTime",
          "type": "T::Moment",
          "value": "b80b000000000000",
          "docs": [
            " The expected average block time at which BABE should be creating",
            " blocks. Since BABE is probabilistic it is not trivial to figure out",
            " what the expected average block time should be based on the slot",
            " duration and the security parameter `c` (where `1 - c` represents",
            " the probability of a slot being empty)."
          ]
        }
      ],
      "index": 2
    },
    {
      "name": "Timestamp",
      "prefix": "Timestamp",
      "calls": [
        {
          "name": "set",
          "args": [
            {
              "name": "now",
              "type": "Compact<T::Moment>"
            }
          ],
          "docs": [
            " Set the current time.",
            "",
            " This call should be invoked exactly once per block. It will panic at the finalization",
            " phase, if this call hasn't been invoked by that time.",
            "",
            " The timestamp should be greater than the previous one by the amount specified by",
            " `MinimumPeriod`.",
            "",
            " The dispatch origin for this call must be `Inherent`.",
            "",
            " # <weight>",
            " - `O(T)` where `T` complexity of `on_timestamp_set`",
            " - 1 storage read and 1 storage mutation (codec `O(1)`). (because of `DidUpdate::take` in `on_finalize`)",
            " - 1 event handler `on_timestamp_set` `O(T)`.",
            " # <\/weight>"
          ],
          "look_up": "0300"
        }
      ],
      "events": [
        {
          "name": "BatchInterrupted",
          "args": [
            "u32",
            "DispatchError"
          ],
          "docs": [
            " Batch of dispatches did not complete fully. Index of first failing dispatch given, as",
            " well as the error. [index, error]"
          ],
          "look_up": "0300"
        },
        {
          "name": "BatchCompleted",
          "args": [],
          "docs": [
            " Batch of dispatches completed fully with no error."
          ],
          "look_up": "0301"
        }
      ],
      "errors": [
        {
          "name": "InvalidSpecName",
          "docs": [
            " The name of specification does not match between the current runtime",
            " and the new runtime."
          ]
        },
        {
          "name": "SpecVersionNeedsToIncrease",
          "docs": [
            " The specification version is not allowed to decrease between the current runtime",
            " and the new runtime."
          ]
        },
        {
          "name": "FailedToExtractRuntimeVersion",
          "docs": [
            " Failed to extract the runtime version from the new runtime.",
            "",
            " Either calling `Core_version` or decoding `RuntimeVersion` failed."
          ]
        },
        {
          "name": "NonDefaultComposite",
          "docs": [
            " Suicide called when the account has non-default composite data."
          ]
        },
        {
          "name": "NonZeroRefCount",
          "docs": [
            " There is a non-zero reference count preventing the account from being purged."
          ]
        }
      ],
      "constants": [
        {
          "name": "MinimumPeriod",
          "type": "T::Moment",
          "value": "dc05000000000000",
          "docs": [
            " The minimum period between blocks. Beware that this is different to the *expected* period",
            " that the block production apparatus provides. Your chosen consensus system will generally",
            " work with this to determine a sensible block time. e.g. For Aura, it will be double this",
            " period on default settings."
          ]
        }
      ],
      "index": 3
    },
    {
      "name": "Authorship",
      "prefix": "Authorship",
      "calls": [
        {
          "name": "set_uncles",
          "args": [
            {
              "name": "new_uncles",
              "type": "Vec<T::Header>"
            }
          ],
          "docs": [
            " Provide a set of uncles."
          ],
          "look_up": "0400"
        }
      ],
      "events": [
        {
          "name": "BatchInterrupted",
          "args": [
            "u32",
            "DispatchError"
          ],
          "docs": [
            " Batch of dispatches did not complete fully. Index of first failing dispatch given, as",
            " well as the error. [index, error]"
          ],
          "look_up": "0400"
        },
        {
          "name": "BatchCompleted",
          "args": [],
          "docs": [
            " Batch of dispatches completed fully with no error."
          ],
          "look_up": "0401"
        }
      ],
      "errors": [
        {
          "name": "InvalidUncleParent",
          "docs": [
            " The uncle parent not in the chain."
          ]
        },
        {
          "name": "UnclesAlreadySet",
          "docs": [
            " Uncles already set in the block."
          ]
        },
        {
          "name": "TooManyUncles",
          "docs": [
            " Too many uncles."
          ]
        },
        {
          "name": "GenesisUncle",
          "docs": [
            " The uncle is genesis."
          ]
        },
        {
          "name": "TooHighUncle",
          "docs": [
            " The uncle is too high in chain."
          ]
        },
        {
          "name": "UncleAlreadyIncluded",
          "docs": [
            " The uncle is already included."
          ]
        },
        {
          "name": "OldUncle",
          "docs": [
            " The uncle isn't recent enough to be included."
          ]
        }
      ],
      "constants": [
        {
          "name": "MinimumPeriod",
          "type": "T::Moment",
          "value": "dc05000000000000",
          "docs": [
            " The minimum period between blocks. Beware that this is different to the *expected* period",
            " that the block production apparatus provides. Your chosen consensus system will generally",
            " work with this to determine a sensible block time. e.g. For Aura, it will be double this",
            " period on default settings."
          ]
        }
      ],
      "index": 4
    },
    {
      "name": "Indices",
      "prefix": "Indices",
      "calls": [
        {
          "name": "claim",
          "args": [
            {
              "name": "index",
              "type": "T::AccountIndex"
            }
          ],
          "docs": [
            " Assign an previously unassigned index.",
            "",
            " Payment: `Deposit` is reserved from the sender account.",
            "",
            " The dispatch origin for this call must be _Signed_.",
            "",
            " - `index`: the index to be claimed. This must not be in use.",
            "",
            " Emits `IndexAssigned` if successful.",
            "",
            " # <weight>",
            " - `O(1)`.",
            " - One storage mutation (codec `O(1)`).",
            " - One reserve operation.",
            " - One event.",
            " -------------------",
            " - Base Weight: 28.69 \u00b5s",
            " - DB Weight: 1 Read\/Write (Accounts)",
            " # <\/weight>"
          ],
          "look_up": "0500"
        },
        {
          "name": "transfer",
          "args": [
            {
              "name": "new",
              "type": "T::AccountId"
            },
            {
              "name": "index",
              "type": "T::AccountIndex"
            }
          ],
          "docs": [
            " Assign an index already owned by the sender to another account. The balance reservation",
            " is effectively transferred to the new account.",
            "",
            " The dispatch origin for this call must be _Signed_.",
            "",
            " - `index`: the index to be re-assigned. This must be owned by the sender.",
            " - `new`: the new owner of the index. This function is a no-op if it is equal to sender.",
            "",
            " Emits `IndexAssigned` if successful.",
            "",
            " # <weight>",
            " - `O(1)`.",
            " - One storage mutation (codec `O(1)`).",
            " - One transfer operation.",
            " - One event.",
            " -------------------",
            " - Base Weight: 33.74 \u00b5s",
            " - DB Weight:",
            "    - Reads: Indices Accounts, System Account (recipient)",
            "    - Writes: Indices Accounts, System Account (recipient)",
            " # <\/weight>"
          ],
          "look_up": "0501"
        },
        {
          "name": "free",
          "args": [
            {
              "name": "index",
              "type": "T::AccountIndex"
            }
          ],
          "docs": [
            " Free up an index owned by the sender.",
            "",
            " Payment: Any previous deposit placed for the index is unreserved in the sender account.",
            "",
            " The dispatch origin for this call must be _Signed_ and the sender must own the index.",
            "",
            " - `index`: the index to be freed. This must be owned by the sender.",
            "",
            " Emits `IndexFreed` if successful.",
            "",
            " # <weight>",
            " - `O(1)`.",
            " - One storage mutation (codec `O(1)`).",
            " - One reserve operation.",
            " - One event.",
            " -------------------",
            " - Base Weight: 25.53 \u00b5s",
            " - DB Weight: 1 Read\/Write (Accounts)",
            " # <\/weight>"
          ],
          "look_up": "0502"
        },
        {
          "name": "force_transfer",
          "args": [
            {
              "name": "new",
              "type": "T::AccountId"
            },
            {
              "name": "index",
              "type": "T::AccountIndex"
            },
            {
              "name": "freeze",
              "type": "bool"
            }
          ],
          "docs": [
            " Force an index to an account. This doesn't require a deposit. If the index is already",
            " held, then any deposit is reimbursed to its current owner.",
            "",
            " The dispatch origin for this call must be _Root_.",
            "",
            " - `index`: the index to be (re-)assigned.",
            " - `new`: the new owner of the index. This function is a no-op if it is equal to sender.",
            " - `freeze`: if set to `true`, will freeze the index so it cannot be transferred.",
            "",
            " Emits `IndexAssigned` if successful.",
            "",
            " # <weight>",
            " - `O(1)`.",
            " - One storage mutation (codec `O(1)`).",
            " - Up to one reserve operation.",
            " - One event.",
            " -------------------",
            " - Base Weight: 26.83 \u00b5s",
            " - DB Weight:",
            "    - Reads: Indices Accounts, System Account (original owner)",
            "    - Writes: Indices Accounts, System Account (original owner)",
            " # <\/weight>"
          ],
          "look_up": "0503"
        },
        {
          "name": "freeze",
          "args": [
            {
              "name": "index",
              "type": "T::AccountIndex"
            }
          ],
          "docs": [
            " Freeze an index so it will always point to the sender account. This consumes the deposit.",
            "",
            " The dispatch origin for this call must be _Signed_ and the signing account must have a",
            " non-frozen account `index`.",
            "",
            " - `index`: the index to be frozen in place.",
            "",
            " Emits `IndexFrozen` if successful.",
            "",
            " # <weight>",
            " - `O(1)`.",
            " - One storage mutation (codec `O(1)`).",
            " - Up to one slash operation.",
            " - One event.",
            " -------------------",
            " - Base Weight: 30.86 \u00b5s",
            " - DB Weight: 1 Read\/Write (Accounts)",
            " # <\/weight>"
          ],
          "look_up": "0504"
        }
      ],
      "events": [
        {
          "name": "IndexAssigned",
          "args": [
            "AccountId",
            "AccountIndex"
          ],
          "docs": [
            " A account index was assigned. [who, index]"
          ],
          "look_up": "0500"
        },
        {
          "name": "IndexFreed",
          "args": [
            "AccountIndex"
          ],
          "docs": [
            " A account index has been freed up (unassigned). [index]"
          ],
          "look_up": "0501"
        },
        {
          "name": "IndexFrozen",
          "args": [
            "AccountIndex",
            "AccountId"
          ],
          "docs": [
            " A account index has been frozen to its current account ID. [who, index]"
          ],
          "look_up": "0502"
        }
      ],
      "errors": [
        {
          "name": "InvalidUncleParent",
          "docs": [
            " The uncle parent not in the chain."
          ]
        },
        {
          "name": "UnclesAlreadySet",
          "docs": [
            " Uncles already set in the block."
          ]
        },
        {
          "name": "TooManyUncles",
          "docs": [
            " Too many uncles."
          ]
        },
        {
          "name": "GenesisUncle",
          "docs": [
            " The uncle is genesis."
          ]
        },
        {
          "name": "TooHighUncle",
          "docs": [
            " The uncle is too high in chain."
          ]
        },
        {
          "name": "UncleAlreadyIncluded",
          "docs": [
            " The uncle is already included."
          ]
        },
        {
          "name": "OldUncle",
          "docs": [
            " The uncle isn't recent enough to be included."
          ]
        }
      ],
      "constants": [
        {
          "name": "Deposit",
          "type": "BalanceOf<T>",
          "value": "00407a10f35a00000000000000000000",
          "docs": [
            " The deposit needed for reserving an index."
          ]
        }
      ],
      "index": 5
    },
    {
      "name": "Balances",
      "prefix": "Balances",
      "calls": [
        {
          "name": "transfer",
          "args": [
            {
              "name": "dest",
              "type": "<T::Lookup as StaticLookup>::Source"
            },
            {
              "name": "value",
              "type": "Compact<T::Balance>"
            }
          ],
          "docs": [
            " Transfer some liquid free balance to another account.",
            "",
            " `transfer` will set the `FreeBalance` of the sender and receiver.",
            " It will decrease the total issuance of the system by the `TransferFee`.",
            " If the sender's account is below the existential deposit as a result",
            " of the transfer, the account will be reaped.",
            "",
            " The dispatch origin for this call must be `Signed` by the transactor.",
            "",
            " # <weight>",
            " - Dependent on arguments but not critical, given proper implementations for",
            "   input config types. See related functions below.",
            " - It contains a limited number of reads and writes internally and no complex computation.",
            "",
            " Related functions:",
            "",
            "   - `ensure_can_withdraw` is always called internally but has a bounded complexity.",
            "   - Transferring balances to accounts that did not exist before will cause",
            "      `T::OnNewAccount::on_new_account` to be called.",
            "   - Removing enough funds from an account will trigger `T::DustRemoval::on_unbalanced`.",
            "   - `transfer_keep_alive` works the same way as `transfer`, but has an additional",
            "     check that the transfer will not kill the origin account.",
            " ---------------------------------",
            " - Base Weight: 73.64 \u00b5s, worst case scenario (account created, account removed)",
            " - DB Weight: 1 Read and 1 Write to destination account",
            " - Origin account is already in memory, so no DB operations for them.",
            " # <\/weight>"
          ],
          "look_up": "0600"
        },
        {
          "name": "set_balance",
          "args": [
            {
              "name": "who",
              "type": "<T::Lookup as StaticLookup>::Source"
            },
            {
              "name": "new_free",
              "type": "Compact<T::Balance>"
            },
            {
              "name": "new_reserved",
              "type": "Compact<T::Balance>"
            }
          ],
          "docs": [
            " Set the balances of a given account.",
            "",
            " This will alter `FreeBalance` and `ReservedBalance` in storage. it will",
            " also decrease the total issuance of the system (`TotalIssuance`).",
            " If the new free or reserved balance is below the existential deposit,",
            " it will reset the account nonce (`frame_system::AccountNonce`).",
            "",
            " The dispatch origin for this call is `root`.",
            "",
            " # <weight>",
            " - Independent of the arguments.",
            " - Contains a limited number of reads and writes.",
            " ---------------------",
            " - Base Weight:",
            "     - Creating: 27.56 \u00b5s",
            "     - Killing: 35.11 \u00b5s",
            " - DB Weight: 1 Read, 1 Write to `who`",
            " # <\/weight>"
          ],
          "look_up": "0601"
        },
        {
          "name": "force_transfer",
          "args": [
            {
              "name": "source",
              "type": "<T::Lookup as StaticLookup>::Source"
            },
            {
              "name": "dest",
              "type": "<T::Lookup as StaticLookup>::Source"
            },
            {
              "name": "value",
              "type": "Compact<T::Balance>"
            }
          ],
          "docs": [
            " Exactly as `transfer`, except the origin must be root and the source account may be",
            " specified.",
            " # <weight>",
            " - Same as transfer, but additional read and write because the source account is",
            "   not assumed to be in the overlay.",
            " # <\/weight>"
          ],
          "look_up": "0602"
        },
        {
          "name": "transfer_keep_alive",
          "args": [
            {
              "name": "dest",
              "type": "<T::Lookup as StaticLookup>::Source"
            },
            {
              "name": "value",
              "type": "Compact<T::Balance>"
            }
          ],
          "docs": [
            " Same as the [`transfer`] call, but with a check that the transfer will not kill the",
            " origin account.",
            "",
            " 99% of the time you want [`transfer`] instead.",
            "",
            " [`transfer`]: struct.Module.html#method.transfer",
            " # <weight>",
            " - Cheaper than transfer because account cannot be killed.",
            " - Base Weight: 51.4 \u00b5s",
            " - DB Weight: 1 Read and 1 Write to dest (sender is in overlay already)",
            " #<\/weight>"
          ],
          "look_up": "0603"
        }
      ],
      "events": [
        {
          "name": "Endowed",
          "args": [
            "AccountId",
            "Balance"
          ],
          "docs": [
            " An account was created with some free balance. [account, free_balance]"
          ],
          "look_up": "0600"
        },
        {
          "name": "DustLost",
          "args": [
            "AccountId",
            "Balance"
          ],
          "docs": [
            " An account was removed whose balance was non-zero but below ExistentialDeposit,",
            " resulting in an outright loss. [account, balance]"
          ],
          "look_up": "0601"
        },
        {
          "name": "Transfer",
          "args": [
            "AccountId",
            "AccountId",
            "Balance"
          ],
          "docs": [
            " Transfer succeeded. [from, to, value]"
          ],
          "look_up": "0602"
        },
        {
          "name": "BalanceSet",
          "args": [
            "AccountId",
            "Balance",
            "Balance"
          ],
          "docs": [
            " A balance was set by root. [who, free, reserved]"
          ],
          "look_up": "0603"
        },
        {
          "name": "Deposit",
          "args": [
            "AccountId",
            "Balance"
          ],
          "docs": [
            " Some amount was deposited (e.g. for transaction fees). [who, deposit]"
          ],
          "look_up": "0604"
        },
        {
          "name": "Reserved",
          "args": [
            "AccountId",
            "Balance"
          ],
          "docs": [
            " Some balance was reserved (moved from free to reserved). [who, value]"
          ],
          "look_up": "0605"
        },
        {
          "name": "Unreserved",
          "args": [
            "AccountId",
            "Balance"
          ],
          "docs": [
            " Some balance was unreserved (moved from reserved to free). [who, value]"
          ],
          "look_up": "0606"
        },
        {
          "name": "ReserveRepatriated",
          "args": [
            "AccountId",
            "AccountId",
            "Balance",
            "Status"
          ],
          "docs": [
            " Some balance was moved from the reserve of the first account to the second account.",
            " Final argument indicates the destination balance type.",
            " [from, to, balance, destination_status]"
          ],
          "look_up": "0607"
        }
      ],
      "errors": [
        {
          "name": "VestingBalance",
          "docs": [
            " Vesting balance too high to send value"
          ]
        },
        {
          "name": "LiquidityRestrictions",
          "docs": [
            " Account liquidity restrictions prevent withdrawal"
          ]
        },
        {
          "name": "Overflow",
          "docs": [
            " Got an overflow after adding"
          ]
        },
        {
          "name": "InsufficientBalance",
          "docs": [
            " Balance too low to send value"
          ]
        },
        {
          "name": "ExistentialDeposit",
          "docs": [
            " Value too low to create account due to existential deposit"
          ]
        },
        {
          "name": "KeepAlive",
          "docs": [
            " Transfer\/payment would kill account"
          ]
        },
        {
          "name": "ExistingVestingSchedule",
          "docs": [
            " A vesting schedule already exists for this account"
          ]
        },
        {
          "name": "DeadAccount",
          "docs": [
            " Beneficiary account must pre-exist"
          ]
        }
      ],
      "constants": [
        {
          "name": "ExistentialDeposit",
          "type": "T::Balance",
          "value": "00407a10f35a00000000000000000000",
          "docs": [
            " The minimum amount required to keep an account open."
          ]
        }
      ],
      "index": 6
    },
    {
      "name": "TransactionPayment",
      "prefix": "TransactionPayment",
      "calls": [
        {
          "name": "transfer",
          "args": [
            {
              "name": "dest",
              "type": "<T::Lookup as StaticLookup>::Source"
            },
            {
              "name": "value",
              "type": "Compact<T::Balance>"
            }
          ],
          "docs": [
            " Transfer some liquid free balance to another account.",
            "",
            " `transfer` will set the `FreeBalance` of the sender and receiver.",
            " It will decrease the total issuance of the system by the `TransferFee`.",
            " If the sender's account is below the existential deposit as a result",
            " of the transfer, the account will be reaped.",
            "",
            " The dispatch origin for this call must be `Signed` by the transactor.",
            "",
            " # <weight>",
            " - Dependent on arguments but not critical, given proper implementations for",
            "   input config types. See related functions below.",
            " - It contains a limited number of reads and writes internally and no complex computation.",
            "",
            " Related functions:",
            "",
            "   - `ensure_can_withdraw` is always called internally but has a bounded complexity.",
            "   - Transferring balances to accounts that did not exist before will cause",
            "      `T::OnNewAccount::on_new_account` to be called.",
            "   - Removing enough funds from an account will trigger `T::DustRemoval::on_unbalanced`.",
            "   - `transfer_keep_alive` works the same way as `transfer`, but has an additional",
            "     check that the transfer will not kill the origin account.",
            " ---------------------------------",
            " - Base Weight: 73.64 \u00b5s, worst case scenario (account created, account removed)",
            " - DB Weight: 1 Read and 1 Write to destination account",
            " - Origin account is already in memory, so no DB operations for them.",
            " # <\/weight>"
          ],
          "look_up": "0700"
        },
        {
          "name": "set_balance",
          "args": [
            {
              "name": "who",
              "type": "<T::Lookup as StaticLookup>::Source"
            },
            {
              "name": "new_free",
              "type": "Compact<T::Balance>"
            },
            {
              "name": "new_reserved",
              "type": "Compact<T::Balance>"
            }
          ],
          "docs": [
            " Set the balances of a given account.",
            "",
            " This will alter `FreeBalance` and `ReservedBalance` in storage. it will",
            " also decrease the total issuance of the system (`TotalIssuance`).",
            " If the new free or reserved balance is below the existential deposit,",
            " it will reset the account nonce (`frame_system::AccountNonce`).",
            "",
            " The dispatch origin for this call is `root`.",
            "",
            " # <weight>",
            " - Independent of the arguments.",
            " - Contains a limited number of reads and writes.",
            " ---------------------",
            " - Base Weight:",
            "     - Creating: 27.56 \u00b5s",
            "     - Killing: 35.11 \u00b5s",
            " - DB Weight: 1 Read, 1 Write to `who`",
            " # <\/weight>"
          ],
          "look_up": "0701"
        },
        {
          "name": "force_transfer",
          "args": [
            {
              "name": "source",
              "type": "<T::Lookup as StaticLookup>::Source"
            },
            {
              "name": "dest",
              "type": "<T::Lookup as StaticLookup>::Source"
            },
            {
              "name": "value",
              "type": "Compact<T::Balance>"
            }
          ],
          "docs": [
            " Exactly as `transfer`, except the origin must be root and the source account may be",
            " specified.",
            " # <weight>",
            " - Same as transfer, but additional read and write because the source account is",
            "   not assumed to be in the overlay.",
            " # <\/weight>"
          ],
          "look_up": "0702"
        },
        {
          "name": "transfer_keep_alive",
          "args": [
            {
              "name": "dest",
              "type": "<T::Lookup as StaticLookup>::Source"
            },
            {
              "name": "value",
              "type": "Compact<T::Balance>"
            }
          ],
          "docs": [
            " Same as the [`transfer`] call, but with a check that the transfer will not kill the",
            " origin account.",
            "",
            " 99% of the time you want [`transfer`] instead.",
            "",
            " [`transfer`]: struct.Module.html#method.transfer",
            " # <weight>",
            " - Cheaper than transfer because account cannot be killed.",
            " - Base Weight: 51.4 \u00b5s",
            " - DB Weight: 1 Read and 1 Write to dest (sender is in overlay already)",
            " #<\/weight>"
          ],
          "look_up": "0703"
        }
      ],
      "events": [
        {
          "name": "Endowed",
          "args": [
            "AccountId",
            "Balance"
          ],
          "docs": [
            " An account was created with some free balance. [account, free_balance]"
          ],
          "look_up": "0700"
        },
        {
          "name": "DustLost",
          "args": [
            "AccountId",
            "Balance"
          ],
          "docs": [
            " An account was removed whose balance was non-zero but below ExistentialDeposit,",
            " resulting in an outright loss. [account, balance]"
          ],
          "look_up": "0701"
        },
        {
          "name": "Transfer",
          "args": [
            "AccountId",
            "AccountId",
            "Balance"
          ],
          "docs": [
            " Transfer succeeded. [from, to, value]"
          ],
          "look_up": "0702"
        },
        {
          "name": "BalanceSet",
          "args": [
            "AccountId",
            "Balance",
            "Balance"
          ],
          "docs": [
            " A balance was set by root. [who, free, reserved]"
          ],
          "look_up": "0703"
        },
        {
          "name": "Deposit",
          "args": [
            "AccountId",
            "Balance"
          ],
          "docs": [
            " Some amount was deposited (e.g. for transaction fees). [who, deposit]"
          ],
          "look_up": "0704"
        },
        {
          "name": "Reserved",
          "args": [
            "AccountId",
            "Balance"
          ],
          "docs": [
            " Some balance was reserved (moved from free to reserved). [who, value]"
          ],
          "look_up": "0705"
        },
        {
          "name": "Unreserved",
          "args": [
            "AccountId",
            "Balance"
          ],
          "docs": [
            " Some balance was unreserved (moved from reserved to free). [who, value]"
          ],
          "look_up": "0706"
        },
        {
          "name": "ReserveRepatriated",
          "args": [
            "AccountId",
            "AccountId",
            "Balance",
            "Status"
          ],
          "docs": [
            " Some balance was moved from the reserve of the first account to the second account.",
            " Final argument indicates the destination balance type.",
            " [from, to, balance, destination_status]"
          ],
          "look_up": "0707"
        }
      ],
      "errors": [
        {
          "name": "VestingBalance",
          "docs": [
            " Vesting balance too high to send value"
          ]
        },
        {
          "name": "LiquidityRestrictions",
          "docs": [
            " Account liquidity restrictions prevent withdrawal"
          ]
        },
        {
          "name": "Overflow",
          "docs": [
            " Got an overflow after adding"
          ]
        },
        {
          "name": "InsufficientBalance",
          "docs": [
            " Balance too low to send value"
          ]
        },
        {
          "name": "ExistentialDeposit",
          "docs": [
            " Value too low to create account due to existential deposit"
          ]
        },
        {
          "name": "KeepAlive",
          "docs": [
            " Transfer\/payment would kill account"
          ]
        },
        {
          "name": "ExistingVestingSchedule",
          "docs": [
            " A vesting schedule already exists for this account"
          ]
        },
        {
          "name": "DeadAccount",
          "docs": [
            " Beneficiary account must pre-exist"
          ]
        }
      ],
      "constants": [
        {
          "name": "TransactionByteFee",
          "type": "BalanceOf<T>",
          "value": "00e40b54020000000000000000000000",
          "docs": [
            " The fee to be paid for making a transaction; the per-byte portion."
          ]
        },
        {
          "name": "WeightToFee",
          "type": "Vec<WeightToFeeCoefficient<BalanceOf<T>>>",
          "value": "0401000000000000000000000000000000000000000001",
          "docs": [
            " The polynomial that is applied in order to derive fee from weight."
          ]
        }
      ],
      "index": 7
    },
    {
      "name": "Staking",
      "prefix": "Staking",
      "calls": [
        {
          "name": "bond",
          "args": [
            {
              "name": "controller",
              "type": "<T::Lookup as StaticLookup>::Source"
            },
            {
              "name": "value",
              "type": "Compact<BalanceOf<T>>"
            },
            {
              "name": "payee",
              "type": "RewardDestination<T::AccountId>"
            }
          ],
          "docs": [
            " Take the origin account as a stash and lock up `value` of its balance. `controller` will",
            " be the account that controls it.",
            "",
            " `value` must be more than the `minimum_balance` specified by `T::Currency`.",
            "",
            " The dispatch origin for this call must be _Signed_ by the stash account.",
            "",
            " Emits `Bonded`.",
            "",
            " # <weight>",
            " - Independent of the arguments. Moderate complexity.",
            " - O(1).",
            " - Three extra DB entries.",
            "",
            " NOTE: Two of the storage writes (`Self::bonded`, `Self::payee`) are _never_ cleaned",
            " unless the `origin` falls below _existential deposit_ and gets removed as dust.",
            " ------------------",
            " Base Weight: 67.87 \u00b5s",
            " DB Weight:",
            " - Read: Bonded, Ledger, [Origin Account], Current Era, History Depth, Locks",
            " - Write: Bonded, Payee, [Origin Account], Locks, Ledger",
            " # <\/weight>"
          ],
          "look_up": "0800"
        },
        {
          "name": "bond_extra",
          "args": [
            {
              "name": "max_additional",
              "type": "Compact<BalanceOf<T>>"
            }
          ],
          "docs": [
            " Add some extra amount that have appeared in the stash `free_balance` into the balance up",
            " for staking.",
            "",
            " Use this if there are additional funds in your stash account that you wish to bond.",
            " Unlike [`bond`] or [`unbond`] this function does not impose any limitation on the amount",
            " that can be added.",
            "",
            " The dispatch origin for this call must be _Signed_ by the stash, not the controller and",
            " it can be only called when [`EraElectionStatus`] is `Closed`.",
            "",
            " Emits `Bonded`.",
            "",
            " # <weight>",
            " - Independent of the arguments. Insignificant complexity.",
            " - O(1).",
            " - One DB entry.",
            " ------------",
            " Base Weight: 54.88 \u00b5s",
            " DB Weight:",
            " - Read: Era Election Status, Bonded, Ledger, [Origin Account], Locks",
            " - Write: [Origin Account], Locks, Ledger",
            " # <\/weight>"
          ],
          "look_up": "0801"
        },
        {
          "name": "unbond",
          "args": [
            {
              "name": "value",
              "type": "Compact<BalanceOf<T>>"
            }
          ],
          "docs": [
            " Schedule a portion of the stash to be unlocked ready for transfer out after the bond",
            " period ends. If this leaves an amount actively bonded less than",
            " T::Currency::minimum_balance(), then it is increased to the full amount.",
            "",
            " Once the unlock period is done, you can call `withdraw_unbonded` to actually move",
            " the funds out of management ready for transfer.",
            "",
            " No more than a limited number of unlocking chunks (see `MAX_UNLOCKING_CHUNKS`)",
            " can co-exists at the same time. In that case, [`Call::withdraw_unbonded`] need",
            " to be called first to remove some of the chunks (if possible).",
            "",
            " The dispatch origin for this call must be _Signed_ by the controller, not the stash.",
            " And, it can be only called when [`EraElectionStatus`] is `Closed`.",
            "",
            " Emits `Unbonded`.",
            "",
            " See also [`Call::withdraw_unbonded`].",
            "",
            " # <weight>",
            " - Independent of the arguments. Limited but potentially exploitable complexity.",
            " - Contains a limited number of reads.",
            " - Each call (requires the remainder of the bonded balance to be above `minimum_balance`)",
            "   will cause a new entry to be inserted into a vector (`Ledger.unlocking`) kept in storage.",
            "   The only way to clean the aforementioned storage item is also user-controlled via",
            "   `withdraw_unbonded`.",
            " - One DB entry.",
            " ----------",
            " Base Weight: 50.34 \u00b5s",
            " DB Weight:",
            " - Read: Era Election Status, Ledger, Current Era, Locks, [Origin Account]",
            " - Write: [Origin Account], Locks, Ledger",
            " <\/weight>"
          ],
          "look_up": "0802"
        },
        {
          "name": "withdraw_unbonded",
          "args": [
            {
              "name": "num_slashing_spans",
              "type": "u32"
            }
          ],
          "docs": [
            " Remove any unlocked chunks from the `unlocking` queue from our management.",
            "",
            " This essentially frees up that balance to be used by the stash account to do",
            " whatever it wants.",
            "",
            " The dispatch origin for this call must be _Signed_ by the controller, not the stash.",
            " And, it can be only called when [`EraElectionStatus`] is `Closed`.",
            "",
            " Emits `Withdrawn`.",
            "",
            " See also [`Call::unbond`].",
            "",
            " # <weight>",
            " - Could be dependent on the `origin` argument and how much `unlocking` chunks exist.",
            "  It implies `consolidate_unlocked` which loops over `Ledger.unlocking`, which is",
            "  indirectly user-controlled. See [`unbond`] for more detail.",
            " - Contains a limited number of reads, yet the size of which could be large based on `ledger`.",
            " - Writes are limited to the `origin` account key.",
            " ---------------",
            " Complexity O(S) where S is the number of slashing spans to remove",
            " Base Weight:",
            " Update: 50.52 + .028 * S \u00b5s",
            " - Reads: EraElectionStatus, Ledger, Current Era, Locks, [Origin Account]",
            " - Writes: [Origin Account], Locks, Ledger",
            " Kill: 79.41 + 2.366 * S \u00b5s",
            " - Reads: EraElectionStatus, Ledger, Current Era, Bonded, Slashing Spans, [Origin Account], Locks",
            " - Writes: Bonded, Slashing Spans (if S > 0), Ledger, Payee, Validators, Nominators, [Origin Account], Locks",
            " - Writes Each: SpanSlash * S",
            " NOTE: Weight annotation is the kill scenario, we refund otherwise.",
            " # <\/weight>"
          ],
          "look_up": "0803"
        },
        {
          "name": "validate",
          "args": [
            {
              "name": "prefs",
              "type": "ValidatorPrefs"
            }
          ],
          "docs": [
            " Declare the desire to validate for the origin controller.",
            "",
            " Effects will be felt at the beginning of the next era.",
            "",
            " The dispatch origin for this call must be _Signed_ by the controller, not the stash.",
            " And, it can be only called when [`EraElectionStatus`] is `Closed`.",
            "",
            " # <weight>",
            " - Independent of the arguments. Insignificant complexity.",
            " - Contains a limited number of reads.",
            " - Writes are limited to the `origin` account key.",
            " -----------",
            " Base Weight: 17.13 \u00b5s",
            " DB Weight:",
            " - Read: Era Election Status, Ledger",
            " - Write: Nominators, Validators",
            " # <\/weight>"
          ],
          "look_up": "0804"
        },
        {
          "name": "nominate",
          "args": [
            {
              "name": "targets",
              "type": "Vec<<T::Lookup as StaticLookup>::Source>"
            }
          ],
          "docs": [
            " Declare the desire to nominate `targets` for the origin controller.",
            "",
            " Effects will be felt at the beginning of the next era. This can only be called when",
            " [`EraElectionStatus`] is `Closed`.",
            "",
            " The dispatch origin for this call must be _Signed_ by the controller, not the stash.",
            " And, it can be only called when [`EraElectionStatus`] is `Closed`.",
            "",
            " # <weight>",
            " - The transaction's complexity is proportional to the size of `targets` (N)",
            " which is capped at CompactAssignments::LIMIT (MAX_NOMINATIONS).",
            " - Both the reads and writes follow a similar pattern.",
            " ---------",
            " Base Weight: 22.34 + .36 * N \u00b5s",
            " where N is the number of targets",
            " DB Weight:",
            " - Reads: Era Election Status, Ledger, Current Era",
            " - Writes: Validators, Nominators",
            " # <\/weight>"
          ],
          "look_up": "0805"
        },
        {
          "name": "chill",
          "args": [],
          "docs": [
            " Declare no desire to either validate or nominate.",
            "",
            " Effects will be felt at the beginning of the next era.",
            "",
            " The dispatch origin for this call must be _Signed_ by the controller, not the stash.",
            " And, it can be only called when [`EraElectionStatus`] is `Closed`.",
            "",
            " # <weight>",
            " - Independent of the arguments. Insignificant complexity.",
            " - Contains one read.",
            " - Writes are limited to the `origin` account key.",
            " --------",
            " Base Weight: 16.53 \u00b5s",
            " DB Weight:",
            " - Read: EraElectionStatus, Ledger",
            " - Write: Validators, Nominators",
            " # <\/weight>"
          ],
          "look_up": "0806"
        },
        {
          "name": "set_payee",
          "args": [
            {
              "name": "payee",
              "type": "RewardDestination<T::AccountId>"
            }
          ],
          "docs": [
            " (Re-)set the payment target for a controller.",
            "",
            " Effects will be felt at the beginning of the next era.",
            "",
            " The dispatch origin for this call must be _Signed_ by the controller, not the stash.",
            "",
            " # <weight>",
            " - Independent of the arguments. Insignificant complexity.",
            " - Contains a limited number of reads.",
            " - Writes are limited to the `origin` account key.",
            " ---------",
            " - Base Weight: 11.33 \u00b5s",
            " - DB Weight:",
            "     - Read: Ledger",
            "     - Write: Payee",
            " # <\/weight>"
          ],
          "look_up": "0807"
        },
        {
          "name": "set_controller",
          "args": [
            {
              "name": "controller",
              "type": "<T::Lookup as StaticLookup>::Source"
            }
          ],
          "docs": [
            " (Re-)set the controller of a stash.",
            "",
            " Effects will be felt at the beginning of the next era.",
            "",
            " The dispatch origin for this call must be _Signed_ by the stash, not the controller.",
            "",
            " # <weight>",
            " - Independent of the arguments. Insignificant complexity.",
            " - Contains a limited number of reads.",
            " - Writes are limited to the `origin` account key.",
            " ----------",
            " Base Weight: 25.22 \u00b5s",
            " DB Weight:",
            " - Read: Bonded, Ledger New Controller, Ledger Old Controller",
            " - Write: Bonded, Ledger New Controller, Ledger Old Controller",
            " # <\/weight>"
          ],
          "look_up": "0808"
        },
        {
          "name": "set_validator_count",
          "args": [
            {
              "name": "new",
              "type": "Compact<u32>"
            }
          ],
          "docs": [
            " Sets the ideal number of validators.",
            "",
            " The dispatch origin must be Root.",
            "",
            " # <weight>",
            " Base Weight: 1.717 \u00b5s",
            " Write: Validator Count",
            " # <\/weight>"
          ],
          "look_up": "0809"
        },
        {
          "name": "increase_validator_count",
          "args": [
            {
              "name": "additional",
              "type": "Compact<u32>"
            }
          ],
          "docs": [
            " Increments the ideal number of validators.",
            "",
            " The dispatch origin must be Root.",
            "",
            " # <weight>",
            " Base Weight: 1.717 \u00b5s",
            " Read\/Write: Validator Count",
            " # <\/weight>"
          ],
          "look_up": "080a"
        },
        {
          "name": "scale_validator_count",
          "args": [
            {
              "name": "factor",
              "type": "Percent"
            }
          ],
          "docs": [
            " Scale up the ideal number of validators by a factor.",
            "",
            " The dispatch origin must be Root.",
            "",
            " # <weight>",
            " Base Weight: 1.717 \u00b5s",
            " Read\/Write: Validator Count",
            " # <\/weight>"
          ],
          "look_up": "080b"
        },
        {
          "name": "force_no_eras",
          "args": [],
          "docs": [
            " Force there to be no new eras indefinitely.",
            "",
            " The dispatch origin must be Root.",
            "",
            " # <weight>",
            " - No arguments.",
            " - Base Weight: 1.857 \u00b5s",
            " - Write: ForceEra",
            " # <\/weight>"
          ],
          "look_up": "080c"
        },
        {
          "name": "force_new_era",
          "args": [],
          "docs": [
            " Force there to be a new era at the end of the next session. After this, it will be",
            " reset to normal (non-forced) behaviour.",
            "",
            " The dispatch origin must be Root.",
            "",
            " # <weight>",
            " - No arguments.",
            " - Base Weight: 1.959 \u00b5s",
            " - Write ForceEra",
            " # <\/weight>"
          ],
          "look_up": "080d"
        },
        {
          "name": "set_invulnerables",
          "args": [
            {
              "name": "validators",
              "type": "Vec<T::AccountId>"
            }
          ],
          "docs": [
            " Set the validators who cannot be slashed (if any).",
            "",
            " The dispatch origin must be Root.",
            "",
            " # <weight>",
            " - O(V)",
            " - Base Weight: 2.208 + .006 * V \u00b5s",
            " - Write: Invulnerables",
            " # <\/weight>"
          ],
          "look_up": "080e"
        },
        {
          "name": "force_unstake",
          "args": [
            {
              "name": "stash",
              "type": "T::AccountId"
            },
            {
              "name": "num_slashing_spans",
              "type": "u32"
            }
          ],
          "docs": [
            " Force a current staker to become completely unstaked, immediately.",
            "",
            " The dispatch origin must be Root.",
            "",
            " # <weight>",
            " O(S) where S is the number of slashing spans to be removed",
            " Base Weight: 53.07 + 2.365 * S \u00b5s",
            " Reads: Bonded, Slashing Spans, Account, Locks",
            " Writes: Bonded, Slashing Spans (if S > 0), Ledger, Payee, Validators, Nominators, Account, Locks",
            " Writes Each: SpanSlash * S",
            " # <\/weight>"
          ],
          "look_up": "080f"
        },
        {
          "name": "force_new_era_always",
          "args": [],
          "docs": [
            " Force there to be a new era at the end of sessions indefinitely.",
            "",
            " The dispatch origin must be Root.",
            "",
            " # <weight>",
            " - Base Weight: 2.05 \u00b5s",
            " - Write: ForceEra",
            " # <\/weight>"
          ],
          "look_up": "0810"
        },
        {
          "name": "cancel_deferred_slash",
          "args": [
            {
              "name": "era",
              "type": "EraIndex"
            },
            {
              "name": "slash_indices",
              "type": "Vec<u32>"
            }
          ],
          "docs": [
            " Cancel enactment of a deferred slash.",
            "",
            " Can be called by the `T::SlashCancelOrigin`.",
            "",
            " Parameters: era and indices of the slashes for that era to kill.",
            "",
            " # <weight>",
            " Complexity: O(U + S)",
            " with U unapplied slashes weighted with U=1000",
            " and S is the number of slash indices to be canceled.",
            " - Base: 5870 + 34.61 * S \u00b5s",
            " - Read: Unapplied Slashes",
            " - Write: Unapplied Slashes",
            " # <\/weight>"
          ],
          "look_up": "0811"
        },
        {
          "name": "payout_stakers",
          "args": [
            {
              "name": "validator_stash",
              "type": "T::AccountId"
            },
            {
              "name": "era",
              "type": "EraIndex"
            }
          ],
          "docs": [
            " Pay out all the stakers behind a single validator for a single era.",
            "",
            " - `validator_stash` is the stash account of the validator. Their nominators, up to",
            "   `T::MaxNominatorRewardedPerValidator`, will also receive their rewards.",
            " - `era` may be any era between `[current_era - history_depth; current_era]`.",
            "",
            " The origin of this call must be _Signed_. Any account can call this function, even if",
            " it is not one of the stakers.",
            "",
            " This can only be called when [`EraElectionStatus`] is `Closed`.",
            "",
            " # <weight>",
            " - Time complexity: at most O(MaxNominatorRewardedPerValidator).",
            " - Contains a limited number of reads and writes.",
            " -----------",
            " N is the Number of payouts for the validator (including the validator)",
            " Base Weight:",
            " - Reward Destination Staked: 110 + 54.2 * N \u00b5s (Median Slopes)",
            " - Reward Destination Controller (Creating): 120 + 41.95 * N \u00b5s (Median Slopes)",
            " DB Weight:",
            " - Read: EraElectionStatus, CurrentEra, HistoryDepth, ErasValidatorReward,",
            "         ErasStakersClipped, ErasRewardPoints, ErasValidatorPrefs (8 items)",
            " - Read Each: Bonded, Ledger, Payee, Locks, System Account (5 items)",
            " - Write Each: System Account, Locks, Ledger (3 items)",
            " # <\/weight>"
          ],
          "look_up": "0812"
        },
        {
          "name": "rebond",
          "args": [
            {
              "name": "value",
              "type": "Compact<BalanceOf<T>>"
            }
          ],
          "docs": [
            " Rebond a portion of the stash scheduled to be unlocked.",
            "",
            " The dispatch origin must be signed by the controller, and it can be only called when",
            " [`EraElectionStatus`] is `Closed`.",
            "",
            " # <weight>",
            " - Time complexity: O(L), where L is unlocking chunks",
            " - Bounded by `MAX_UNLOCKING_CHUNKS`.",
            " - Storage changes: Can't increase storage, only decrease it.",
            " ---------------",
            " - Base Weight: 34.51 \u00b5s * .048 L \u00b5s",
            " - DB Weight:",
            "     - Reads: EraElectionStatus, Ledger, Locks, [Origin Account]",
            "     - Writes: [Origin Account], Locks, Ledger",
            " # <\/weight>"
          ],
          "look_up": "0813"
        },
        {
          "name": "set_history_depth",
          "args": [
            {
              "name": "new_history_depth",
              "type": "Compact<EraIndex>"
            },
            {
              "name": "_era_items_deleted",
              "type": "Compact<u32>"
            }
          ],
          "docs": [
            " Set `HistoryDepth` value. This function will delete any history information",
            " when `HistoryDepth` is reduced.",
            "",
            " Parameters:",
            " - `new_history_depth`: The new history depth you would like to set.",
            " - `era_items_deleted`: The number of items that will be deleted by this dispatch.",
            "    This should report all the storage items that will be deleted by clearing old",
            "    era history. Needed to report an accurate weight for the dispatch. Trusted by",
            "    `Root` to report an accurate number.",
            "",
            " Origin must be root.",
            "",
            " # <weight>",
            " - E: Number of history depths removed, i.e. 10 -> 7 = 3",
            " - Base Weight: 29.13 * E \u00b5s",
            " - DB Weight:",
            "     - Reads: Current Era, History Depth",
            "     - Writes: History Depth",
            "     - Clear Prefix Each: Era Stakers, EraStakersClipped, ErasValidatorPrefs",
            "     - Writes Each: ErasValidatorReward, ErasRewardPoints, ErasTotalStake, ErasStartSessionIndex",
            " # <\/weight>"
          ],
          "look_up": "0814"
        },
        {
          "name": "reap_stash",
          "args": [
            {
              "name": "stash",
              "type": "T::AccountId"
            },
            {
              "name": "num_slashing_spans",
              "type": "u32"
            }
          ],
          "docs": [
            " Remove all data structure concerning a staker\/stash once its balance is zero.",
            " This is essentially equivalent to `withdraw_unbonded` except it can be called by anyone",
            " and the target `stash` must have no funds left.",
            "",
            " This can be called from any origin.",
            "",
            " - `stash`: The stash account to reap. Its balance must be zero.",
            "",
            " # <weight>",
            " Complexity: O(S) where S is the number of slashing spans on the account.",
            " Base Weight: 75.94 + 2.396 * S \u00b5s",
            " DB Weight:",
            " - Reads: Stash Account, Bonded, Slashing Spans, Locks",
            " - Writes: Bonded, Slashing Spans (if S > 0), Ledger, Payee, Validators, Nominators, Stash Account, Locks",
            " - Writes Each: SpanSlash * S",
            " # <\/weight>"
          ],
          "look_up": "0815"
        },
        {
          "name": "submit_election_solution",
          "args": [
            {
              "name": "winners",
              "type": "Vec<ValidatorIndex>"
            },
            {
              "name": "compact",
              "type": "CompactAssignments"
            },
            {
              "name": "score",
              "type": "ElectionScore"
            },
            {
              "name": "era",
              "type": "EraIndex"
            },
            {
              "name": "size",
              "type": "ElectionSize"
            }
          ],
          "docs": [
            " Submit an election result to the chain. If the solution:",
            "",
            " 1. is valid.",
            " 2. has a better score than a potentially existing solution on chain.",
            "",
            " then, it will be _put_ on chain.",
            "",
            " A solution consists of two pieces of data:",
            "",
            " 1. `winners`: a flat vector of all the winners of the round.",
            " 2. `assignments`: the compact version of an assignment vector that encodes the edge",
            "    weights.",
            "",
            " Both of which may be computed using _phragmen_, or any other algorithm.",
            "",
            " Additionally, the submitter must provide:",
            "",
            " - The `score` that they claim their solution has.",
            "",
            " Both validators and nominators will be represented by indices in the solution. The",
            " indices should respect the corresponding types ([`ValidatorIndex`] and",
            " [`NominatorIndex`]). Moreover, they should be valid when used to index into",
            " [`SnapshotValidators`] and [`SnapshotNominators`]. Any invalid index will cause the",
            " solution to be rejected. These two storage items are set during the election window and",
            " may be used to determine the indices.",
            "",
            " A solution is valid if:",
            "",
            " 0. It is submitted when [`EraElectionStatus`] is `Open`.",
            " 1. Its claimed score is equal to the score computed on-chain.",
            " 2. Presents the correct number of winners.",
            " 3. All indexes must be value according to the snapshot vectors. All edge values must",
            "    also be correct and should not overflow the granularity of the ratio type (i.e. 256",
            "    or billion).",
            " 4. For each edge, all targets are actually nominated by the voter.",
            " 5. Has correct self-votes.",
            "",
            " A solutions score is consisted of 3 parameters:",
            "",
            " 1. `min { support.total }` for each support of a winner. This value should be maximized.",
            " 2. `sum { support.total }` for each support of a winner. This value should be minimized.",
            " 3. `sum { support.total^2 }` for each support of a winner. This value should be",
            "    minimized (to ensure less variance)",
            "",
            " # <weight>",
            " See `crate::weight` module.",
            " # <\/weight>"
          ],
          "look_up": "0816"
        },
        {
          "name": "submit_election_solution_unsigned",
          "args": [
            {
              "name": "winners",
              "type": "Vec<ValidatorIndex>"
            },
            {
              "name": "compact",
              "type": "CompactAssignments"
            },
            {
              "name": "score",
              "type": "ElectionScore"
            },
            {
              "name": "era",
              "type": "EraIndex"
            },
            {
              "name": "size",
              "type": "ElectionSize"
            }
          ],
          "docs": [
            " Unsigned version of `submit_election_solution`.",
            "",
            " Note that this must pass the [`ValidateUnsigned`] check which only allows transactions",
            " from the local node to be included. In other words, only the block author can include a",
            " transaction in the block.",
            "",
            " # <weight>",
            " See `crate::weight` module.",
            " # <\/weight>"
          ],
          "look_up": "0817"
        }
      ],
      "events": [
        {
          "name": "EraPayout",
          "args": [
            "EraIndex",
            "Balance",
            "Balance"
          ],
          "docs": [
            " The era payout has been set; the first balance is the validator-payout; the second is",
            " the remainder from the maximum amount of reward.",
            " [era_index, validator_payout, remainder]"
          ],
          "look_up": "0800"
        },
        {
          "name": "Reward",
          "args": [
            "AccountId",
            "Balance"
          ],
          "docs": [
            " The staker has been rewarded by this amount. [stash, amount]"
          ],
          "look_up": "0801"
        },
        {
          "name": "Slash",
          "args": [
            "AccountId",
            "Balance"
          ],
          "docs": [
            " One validator (and its nominators) has been slashed by the given amount.",
            " [validator, amount]"
          ],
          "look_up": "0802"
        },
        {
          "name": "OldSlashingReportDiscarded",
          "args": [
            "SessionIndex"
          ],
          "docs": [
            " An old slashing report from a prior era was discarded because it could",
            " not be processed. [session_index]"
          ],
          "look_up": "0803"
        },
        {
          "name": "StakingElection",
          "args": [
            "ElectionCompute"
          ],
          "docs": [
            " A new set of stakers was elected with the given [compute]."
          ],
          "look_up": "0804"
        },
        {
          "name": "SolutionStored",
          "args": [
            "ElectionCompute"
          ],
          "docs": [
            " A new solution for the upcoming election has been stored. [compute]"
          ],
          "look_up": "0805"
        },
        {
          "name": "Bonded",
          "args": [
            "AccountId",
            "Balance"
          ],
          "docs": [
            " An account has bonded this amount. [stash, amount]",
            "",
            " NOTE: This event is only emitted when funds are bonded via a dispatchable. Notably,",
            " it will not be emitted for staking rewards when they are added to stake."
          ],
          "look_up": "0806"
        },
        {
          "name": "Unbonded",
          "args": [
            "AccountId",
            "Balance"
          ],
          "docs": [
            " An account has unbonded this amount. [stash, amount]"
          ],
          "look_up": "0807"
        },
        {
          "name": "Withdrawn",
          "args": [
            "AccountId",
            "Balance"
          ],
          "docs": [
            " An account has called `withdraw_unbonded` and removed unbonding chunks worth `Balance`",
            " from the unlocking queue. [stash, amount]"
          ],
          "look_up": "0808"
        }
      ],
      "errors": [
        {
          "name": "NotController",
          "docs": [
            " Not a controller account."
          ]
        },
        {
          "name": "NotStash",
          "docs": [
            " Not a stash account."
          ]
        },
        {
          "name": "AlreadyBonded",
          "docs": [
            " Stash is already bonded."
          ]
        },
        {
          "name": "AlreadyPaired",
          "docs": [
            " Controller is already paired."
          ]
        },
        {
          "name": "EmptyTargets",
          "docs": [
            " Targets cannot be empty."
          ]
        },
        {
          "name": "DuplicateIndex",
          "docs": [
            " Duplicate index."
          ]
        },
        {
          "name": "InvalidSlashIndex",
          "docs": [
            " Slash record index out of bounds."
          ]
        },
        {
          "name": "InsufficientValue",
          "docs": [
            " Can not bond with value less than minimum balance."
          ]
        },
        {
          "name": "NoMoreChunks",
          "docs": [
            " Can not schedule more unlock chunks."
          ]
        },
        {
          "name": "NoUnlockChunk",
          "docs": [
            " Can not rebond without unlocking chunks."
          ]
        },
        {
          "name": "FundedTarget",
          "docs": [
            " Attempting to target a stash that still has funds."
          ]
        },
        {
          "name": "InvalidEraToReward",
          "docs": [
            " Invalid era to reward."
          ]
        },
        {
          "name": "InvalidNumberOfNominations",
          "docs": [
            " Invalid number of nominations."
          ]
        },
        {
          "name": "NotSortedAndUnique",
          "docs": [
            " Items are not sorted and unique."
          ]
        },
        {
          "name": "AlreadyClaimed",
          "docs": [
            " Rewards for this era have already been claimed for this validator."
          ]
        },
        {
          "name": "OffchainElectionEarlySubmission",
          "docs": [
            " The submitted result is received out of the open window."
          ]
        },
        {
          "name": "OffchainElectionWeakSubmission",
          "docs": [
            " The submitted result is not as good as the one stored on chain."
          ]
        },
        {
          "name": "SnapshotUnavailable",
          "docs": [
            " The snapshot data of the current window is missing."
          ]
        },
        {
          "name": "OffchainElectionBogusWinnerCount",
          "docs": [
            " Incorrect number of winners were presented."
          ]
        },
        {
          "name": "OffchainElectionBogusWinner",
          "docs": [
            " One of the submitted winners is not an active candidate on chain (index is out of range",
            " in snapshot)."
          ]
        },
        {
          "name": "OffchainElectionBogusCompact",
          "docs": [
            " Error while building the assignment type from the compact. This can happen if an index",
            " is invalid, or if the weights _overflow_."
          ]
        },
        {
          "name": "OffchainElectionBogusNominator",
          "docs": [
            " One of the submitted nominators is not an active nominator on chain."
          ]
        },
        {
          "name": "OffchainElectionBogusNomination",
          "docs": [
            " One of the submitted nominators has an edge to which they have not voted on chain."
          ]
        },
        {
          "name": "OffchainElectionSlashedNomination",
          "docs": [
            " One of the submitted nominators has an edge which is submitted before the last non-zero",
            " slash of the target."
          ]
        },
        {
          "name": "OffchainElectionBogusSelfVote",
          "docs": [
            " A self vote must only be originated from a validator to ONLY themselves."
          ]
        },
        {
          "name": "OffchainElectionBogusEdge",
          "docs": [
            " The submitted result has unknown edges that are not among the presented winners."
          ]
        },
        {
          "name": "OffchainElectionBogusScore",
          "docs": [
            " The claimed score does not match with the one computed from the data."
          ]
        },
        {
          "name": "OffchainElectionBogusElectionSize",
          "docs": [
            " The election size is invalid."
          ]
        },
        {
          "name": "CallNotAllowed",
          "docs": [
            " The call is not allowed at the given time due to restrictions of election period."
          ]
        },
        {
          "name": "IncorrectHistoryDepth",
          "docs": [
            " Incorrect previous history depth input provided."
          ]
        },
        {
          "name": "IncorrectSlashingSpans",
          "docs": [
            " Incorrect number of slashing spans provided."
          ]
        }
      ],
      "constants": [
        {
          "name": "SessionsPerEra",
          "type": "SessionIndex",
          "value": "06000000",
          "docs": [
            " Number of sessions per era."
          ]
        },
        {
          "name": "BondingDuration",
          "type": "EraIndex",
          "value": "a0020000",
          "docs": [
            " Number of eras that staked funds must remain bonded for."
          ]
        },
        {
          "name": "SlashDeferDuration",
          "type": "EraIndex",
          "value": "a8000000",
          "docs": [
            " Number of eras that slashes are deferred by, after computation.",
            "",
            " This should be less than the bonding duration.",
            " Set to 0 if slashes should be applied immediately, without opportunity for",
            " intervention."
          ]
        },
        {
          "name": "ElectionLookahead",
          "type": "T::BlockNumber",
          "value": "32000000",
          "docs": [
            " The number of blocks before the end of the era from which election submissions are allowed.",
            "",
            " Setting this to zero will disable the offchain compute and only on-chain seq-phragmen will",
            " be used.",
            "",
            " This is bounded by being within the last session. Hence, setting it to a value more than the",
            " length of a session will be pointless."
          ]
        },
        {
          "name": "MaxIterations",
          "type": "u32",
          "value": "0a000000",
          "docs": [
            " Maximum number of balancing iterations to run in the offchain submission.",
            "",
            " If set to 0, balance_solution will not be executed at all."
          ]
        },
        {
          "name": "MinSolutionScoreBump",
          "type": "Perbill",
          "value": "20a10700",
          "docs": [
            " The threshold of improvement that should be provided for a new solution to be accepted."
          ]
        },
        {
          "name": "MaxNominatorRewardedPerValidator",
          "type": "u32",
          "value": "40000000",
          "docs": [
            " The maximum number of nominators rewarded for each validator.",
            "",
            " For each validator only the `$MaxNominatorRewardedPerValidator` biggest stakers can claim",
            " their reward. This used to limit the i\/o cost for the nominator payout."
          ]
        }
      ],
      "index": 8
    },
    {
      "name": "Session",
      "prefix": "Session",
      "calls": [
        {
          "name": "set_keys",
          "args": [
            {
              "name": "keys",
              "type": "T::Keys"
            },
            {
              "name": "proof",
              "type": "Vec<u8>"
            }
          ],
          "docs": [
            " Sets the session key(s) of the function caller to `keys`.",
            " Allows an account to set its session key prior to becoming a validator.",
            " This doesn't take effect until the next session.",
            "",
            " The dispatch origin of this function must be signed.",
            "",
            " # <weight>",
            " - Complexity: `O(1)`",
            "   Actual cost depends on the number of length of `T::Keys::key_ids()` which is fixed.",
            " - DbReads: `origin account`, `T::ValidatorIdOf`, `NextKeys`",
            " - DbWrites: `origin account`, `NextKeys`",
            " - DbReads per key id: `KeyOwner`",
            " - DbWrites per key id: `KeyOwner`",
            " # <\/weight>"
          ],
          "look_up": "0900"
        },
        {
          "name": "purge_keys",
          "args": [],
          "docs": [
            " Removes any session key(s) of the function caller.",
            " This doesn't take effect until the next session.",
            "",
            " The dispatch origin of this function must be signed.",
            "",
            " # <weight>",
            " - Complexity: `O(1)` in number of key types.",
            "   Actual cost depends on the number of length of `T::Keys::key_ids()` which is fixed.",
            " - DbReads: `T::ValidatorIdOf`, `NextKeys`, `origin account`",
            " - DbWrites: `NextKeys`, `origin account`",
            " - DbWrites per key id: `KeyOwnder`",
            " # <\/weight>"
          ],
          "look_up": "0901"
        }
      ],
      "events": [
        {
          "name": "NewSession",
          "args": [
            "SessionIndex"
          ],
          "docs": [
            " New session has happened. Note that the argument is the [session_index], not the block",
            " number as the type might suggest."
          ],
          "look_up": "0900"
        }
      ],
      "errors": [
        {
          "name": "InvalidProof",
          "docs": [
            " Invalid ownership proof."
          ]
        },
        {
          "name": "NoAssociatedValidatorId",
          "docs": [
            " No associated validator ID for account."
          ]
        },
        {
          "name": "DuplicatedKey",
          "docs": [
            " Registered duplicate key."
          ]
        },
        {
          "name": "NoKeys",
          "docs": [
            " No keys are associated with this account."
          ]
        }
      ],
      "constants": [
        {
          "name": "SessionsPerEra",
          "type": "SessionIndex",
          "value": "06000000",
          "docs": [
            " Number of sessions per era."
          ]
        },
        {
          "name": "BondingDuration",
          "type": "EraIndex",
          "value": "a0020000",
          "docs": [
            " Number of eras that staked funds must remain bonded for."
          ]
        },
        {
          "name": "SlashDeferDuration",
          "type": "EraIndex",
          "value": "a8000000",
          "docs": [
            " Number of eras that slashes are deferred by, after computation.",
            "",
            " This should be less than the bonding duration.",
            " Set to 0 if slashes should be applied immediately, without opportunity for",
            " intervention."
          ]
        },
        {
          "name": "ElectionLookahead",
          "type": "T::BlockNumber",
          "value": "32000000",
          "docs": [
            " The number of blocks before the end of the era from which election submissions are allowed.",
            "",
            " Setting this to zero will disable the offchain compute and only on-chain seq-phragmen will",
            " be used.",
            "",
            " This is bounded by being within the last session. Hence, setting it to a value more than the",
            " length of a session will be pointless."
          ]
        },
        {
          "name": "MaxIterations",
          "type": "u32",
          "value": "0a000000",
          "docs": [
            " Maximum number of balancing iterations to run in the offchain submission.",
            "",
            " If set to 0, balance_solution will not be executed at all."
          ]
        },
        {
          "name": "MinSolutionScoreBump",
          "type": "Perbill",
          "value": "20a10700",
          "docs": [
            " The threshold of improvement that should be provided for a new solution to be accepted."
          ]
        },
        {
          "name": "MaxNominatorRewardedPerValidator",
          "type": "u32",
          "value": "40000000",
          "docs": [
            " The maximum number of nominators rewarded for each validator.",
            "",
            " For each validator only the `$MaxNominatorRewardedPerValidator` biggest stakers can claim",
            " their reward. This used to limit the i\/o cost for the nominator payout."
          ]
        }
      ],
      "index": 9
    },
    {
      "name": "Democracy",
      "prefix": "Democracy",
      "calls": [
        {
          "name": "propose",
          "args": [
            {
              "name": "proposal_hash",
              "type": "T::Hash"
            },
            {
              "name": "value",
              "type": "Compact<BalanceOf<T>>"
            }
          ],
          "docs": [
            " Propose a sensitive action to be taken.",
            "",
            " The dispatch origin of this call must be _Signed_ and the sender must",
            " have funds to cover the deposit.",
            "",
            " - `proposal_hash`: The hash of the proposal preimage.",
            " - `value`: The amount of deposit (must be at least `MinimumDeposit`).",
            "",
            " Emits `Proposed`.",
            "",
            " # <weight>",
            " - Complexity: `O(1)`",
            " - Db reads: `PublicPropCount`, `PublicProps`",
            " - Db writes: `PublicPropCount`, `PublicProps`, `DepositOf`",
            " # <\/weight>"
          ],
          "look_up": "0a00"
        },
        {
          "name": "second",
          "args": [
            {
              "name": "proposal",
              "type": "Compact<PropIndex>"
            },
            {
              "name": "seconds_upper_bound",
              "type": "Compact<u32>"
            }
          ],
          "docs": [
            " Signals agreement with a particular proposal.",
            "",
            " The dispatch origin of this call must be _Signed_ and the sender",
            " must have funds to cover the deposit, equal to the original deposit.",
            "",
            " - `proposal`: The index of the proposal to second.",
            " - `seconds_upper_bound`: an upper bound on the current number of seconds on this",
            "   proposal. Extrinsic is weighted according to this value with no refund.",
            "",
            " # <weight>",
            " - Complexity: `O(S)` where S is the number of seconds a proposal already has.",
            " - Db reads: `DepositOf`",
            " - Db writes: `DepositOf`",
            " # <\/weight>"
          ],
          "look_up": "0a01"
        },
        {
          "name": "vote",
          "args": [
            {
              "name": "ref_index",
              "type": "Compact<ReferendumIndex>"
            },
            {
              "name": "vote",
              "type": "AccountVote<BalanceOf<T>>"
            }
          ],
          "docs": [
            " Vote in a referendum. If `vote.is_aye()`, the vote is to enact the proposal;",
            " otherwise it is a vote to keep the status quo.",
            "",
            " The dispatch origin of this call must be _Signed_.",
            "",
            " - `ref_index`: The index of the referendum to vote for.",
            " - `vote`: The vote configuration.",
            "",
            " # <weight>",
            " - Complexity: `O(R)` where R is the number of referendums the voter has voted on.",
            "   weight is charged as if maximum votes.",
            " - Db reads: `ReferendumInfoOf`, `VotingOf`, `balances locks`",
            " - Db writes: `ReferendumInfoOf`, `VotingOf`, `balances locks`",
            " # <\/weight>"
          ],
          "look_up": "0a02"
        },
        {
          "name": "emergency_cancel",
          "args": [
            {
              "name": "ref_index",
              "type": "ReferendumIndex"
            }
          ],
          "docs": [
            " Schedule an emergency cancellation of a referendum. Cannot happen twice to the same",
            " referendum.",
            "",
            " The dispatch origin of this call must be `CancellationOrigin`.",
            "",
            " -`ref_index`: The index of the referendum to cancel.",
            "",
            " # <weight>",
            " - Complexity: `O(1)`.",
            " - Db reads: `ReferendumInfoOf`, `Cancellations`",
            " - Db writes: `ReferendumInfoOf`, `Cancellations`",
            " # <\/weight>"
          ],
          "look_up": "0a03"
        },
        {
          "name": "external_propose",
          "args": [
            {
              "name": "proposal_hash",
              "type": "T::Hash"
            }
          ],
          "docs": [
            " Schedule a referendum to be tabled once it is legal to schedule an external",
            " referendum.",
            "",
            " The dispatch origin of this call must be `ExternalOrigin`.",
            "",
            " - `proposal_hash`: The preimage hash of the proposal.",
            "",
            " # <weight>",
            " - Complexity `O(V)` with V number of vetoers in the blacklist of proposal.",
            "   Decoding vec of length V. Charged as maximum",
            " - Db reads: `NextExternal`, `Blacklist`",
            " - Db writes: `NextExternal`",
            " # <\/weight>"
          ],
          "look_up": "0a04"
        },
        {
          "name": "external_propose_majority",
          "args": [
            {
              "name": "proposal_hash",
              "type": "T::Hash"
            }
          ],
          "docs": [
            " Schedule a majority-carries referendum to be tabled next once it is legal to schedule",
            " an external referendum.",
            "",
            " The dispatch of this call must be `ExternalMajorityOrigin`.",
            "",
            " - `proposal_hash`: The preimage hash of the proposal.",
            "",
            " Unlike `external_propose`, blacklisting has no effect on this and it may replace a",
            " pre-scheduled `external_propose` call.",
            "",
            " # <weight>",
            " - Complexity: `O(1)`",
            " - Db write: `NextExternal`",
            " # <\/weight>"
          ],
          "look_up": "0a05"
        },
        {
          "name": "external_propose_default",
          "args": [
            {
              "name": "proposal_hash",
              "type": "T::Hash"
            }
          ],
          "docs": [
            " Schedule a negative-turnout-bias referendum to be tabled next once it is legal to",
            " schedule an external referendum.",
            "",
            " The dispatch of this call must be `ExternalDefaultOrigin`.",
            "",
            " - `proposal_hash`: The preimage hash of the proposal.",
            "",
            " Unlike `external_propose`, blacklisting has no effect on this and it may replace a",
            " pre-scheduled `external_propose` call.",
            "",
            " # <weight>",
            " - Complexity: `O(1)`",
            " - Db write: `NextExternal`",
            " # <\/weight>"
          ],
          "look_up": "0a06"
        },
        {
          "name": "fast_track",
          "args": [
            {
              "name": "proposal_hash",
              "type": "T::Hash"
            },
            {
              "name": "voting_period",
              "type": "T::BlockNumber"
            },
            {
              "name": "delay",
              "type": "T::BlockNumber"
            }
          ],
          "docs": [
            " Schedule the currently externally-proposed majority-carries referendum to be tabled",
            " immediately. If there is no externally-proposed referendum currently, or if there is one",
            " but it is not a majority-carries referendum then it fails.",
            "",
            " The dispatch of this call must be `FastTrackOrigin`.",
            "",
            " - `proposal_hash`: The hash of the current external proposal.",
            " - `voting_period`: The period that is allowed for voting on this proposal. Increased to",
            "   `FastTrackVotingPeriod` if too low.",
            " - `delay`: The number of block after voting has ended in approval and this should be",
            "   enacted. This doesn't have a minimum amount.",
            "",
            " Emits `Started`.",
            "",
            " # <weight>",
            " - Complexity: `O(1)`",
            " - Db reads: `NextExternal`, `ReferendumCount`",
            " - Db writes: `NextExternal`, `ReferendumCount`, `ReferendumInfoOf`",
            " - Base Weight: 30.1 \u00b5s",
            " # <\/weight>"
          ],
          "look_up": "0a07"
        },
        {
          "name": "veto_external",
          "args": [
            {
              "name": "proposal_hash",
              "type": "T::Hash"
            }
          ],
          "docs": [
            " Veto and blacklist the external proposal hash.",
            "",
            " The dispatch origin of this call must be `VetoOrigin`.",
            "",
            " - `proposal_hash`: The preimage hash of the proposal to veto and blacklist.",
            "",
            " Emits `Vetoed`.",
            "",
            " # <weight>",
            " - Complexity: `O(V + log(V))` where V is number of `existing vetoers`",
            "   Performs a binary search on `existing_vetoers` which should not be very large.",
            " - Db reads: `NextExternal`, `Blacklist`",
            " - Db writes: `NextExternal`, `Blacklist`",
            " # <\/weight>"
          ],
          "look_up": "0a08"
        },
        {
          "name": "cancel_referendum",
          "args": [
            {
              "name": "ref_index",
              "type": "Compact<ReferendumIndex>"
            }
          ],
          "docs": [
            " Remove a referendum.",
            "",
            " The dispatch origin of this call must be _Root_.",
            "",
            " - `ref_index`: The index of the referendum to cancel.",
            "",
            " # <weight>",
            " - Complexity: `O(1)`.",
            " - Db writes: `ReferendumInfoOf`",
            " # <\/weight>"
          ],
          "look_up": "0a09"
        },
        {
          "name": "cancel_queued",
          "args": [
            {
              "name": "which",
              "type": "ReferendumIndex"
            }
          ],
          "docs": [
            " Cancel a proposal queued for enactment.",
            "",
            " The dispatch origin of this call must be _Root_.",
            "",
            " - `which`: The index of the referendum to cancel.",
            "",
            " # <weight>",
            " - `O(D)` where `D` is the items in the dispatch queue. Weighted as `D = 10`.",
            " - Db reads: `scheduler lookup`, scheduler agenda`",
            " - Db writes: `scheduler lookup`, scheduler agenda`",
            " # <\/weight>"
          ],
          "look_up": "0a0a"
        },
        {
          "name": "delegate",
          "args": [
            {
              "name": "to",
              "type": "T::AccountId"
            },
            {
              "name": "conviction",
              "type": "Conviction"
            },
            {
              "name": "balance",
              "type": "BalanceOf<T>"
            }
          ],
          "docs": [
            " Delegate the voting power (with some given conviction) of the sending account.",
            "",
            " The balance delegated is locked for as long as it's delegated, and thereafter for the",
            " time appropriate for the conviction's lock period.",
            "",
            " The dispatch origin of this call must be _Signed_, and the signing account must either:",
            "   - be delegating already; or",
            "   - have no voting activity (if there is, then it will need to be removed\/consolidated",
            "     through `reap_vote` or `unvote`).",
            "",
            " - `to`: The account whose voting the `target` account's voting power will follow.",
            " - `conviction`: The conviction that will be attached to the delegated votes. When the",
            "   account is undelegated, the funds will be locked for the corresponding period.",
            " - `balance`: The amount of the account's balance to be used in delegating. This must",
            "   not be more than the account's current balance.",
            "",
            " Emits `Delegated`.",
            "",
            " # <weight>",
            " - Complexity: `O(R)` where R is the number of referendums the voter delegating to has",
            "   voted on. Weight is charged as if maximum votes.",
            " - Db reads: 3*`VotingOf`, `origin account locks`",
            " - Db writes: 3*`VotingOf`, `origin account locks`",
            " - Db reads per votes: `ReferendumInfoOf`",
            " - Db writes per votes: `ReferendumInfoOf`",
            " # <\/weight>"
          ],
          "look_up": "0a0b"
        },
        {
          "name": "undelegate",
          "args": [],
          "docs": [
            " Undelegate the voting power of the sending account.",
            "",
            " Tokens may be unlocked following once an amount of time consistent with the lock period",
            " of the conviction with which the delegation was issued.",
            "",
            " The dispatch origin of this call must be _Signed_ and the signing account must be",
            " currently delegating.",
            "",
            " Emits `Undelegated`.",
            "",
            " # <weight>",
            " - Complexity: `O(R)` where R is the number of referendums the voter delegating to has",
            "   voted on. Weight is charged as if maximum votes.",
            " - Db reads: 2*`VotingOf`",
            " - Db writes: 2*`VotingOf`",
            " - Db reads per votes: `ReferendumInfoOf`",
            " - Db writes per votes: `ReferendumInfoOf`",
            " # <\/weight>"
          ],
          "look_up": "0a0c"
        },
        {
          "name": "clear_public_proposals",
          "args": [],
          "docs": [
            " Clears all public proposals.",
            "",
            " The dispatch origin of this call must be _Root_.",
            "",
            " # <weight>",
            " - `O(1)`.",
            " - Db writes: `PublicProps`",
            " # <\/weight>"
          ],
          "look_up": "0a0d"
        },
        {
          "name": "note_preimage",
          "args": [
            {
              "name": "encoded_proposal",
              "type": "Vec<u8>"
            }
          ],
          "docs": [
            " Register the preimage for an upcoming proposal. This doesn't require the proposal to be",
            " in the dispatch queue but does require a deposit, returned once enacted.",
            "",
            " The dispatch origin of this call must be _Signed_.",
            "",
            " - `encoded_proposal`: The preimage of a proposal.",
            "",
            " Emits `PreimageNoted`.",
            "",
            " # <weight>",
            " - Complexity: `O(E)` with E size of `encoded_proposal` (protected by a required deposit).",
            " - Db reads: `Preimages`",
            " - Db writes: `Preimages`",
            " # <\/weight>"
          ],
          "look_up": "0a0e"
        },
        {
          "name": "note_preimage_operational",
          "args": [
            {
              "name": "encoded_proposal",
              "type": "Vec<u8>"
            }
          ],
          "docs": [
            " Same as `note_preimage` but origin is `OperationalPreimageOrigin`."
          ],
          "look_up": "0a0f"
        },
        {
          "name": "note_imminent_preimage",
          "args": [
            {
              "name": "encoded_proposal",
              "type": "Vec<u8>"
            }
          ],
          "docs": [
            " Register the preimage for an upcoming proposal. This requires the proposal to be",
            " in the dispatch queue. No deposit is needed. When this call is successful, i.e.",
            " the preimage has not been uploaded before and matches some imminent proposal,",
            " no fee is paid.",
            "",
            " The dispatch origin of this call must be _Signed_.",
            "",
            " - `encoded_proposal`: The preimage of a proposal.",
            "",
            " Emits `PreimageNoted`.",
            "",
            " # <weight>",
            " - Complexity: `O(E)` with E size of `encoded_proposal` (protected by a required deposit).",
            " - Db reads: `Preimages`",
            " - Db writes: `Preimages`",
            " # <\/weight>"
          ],
          "look_up": "0a10"
        },
        {
          "name": "note_imminent_preimage_operational",
          "args": [
            {
              "name": "encoded_proposal",
              "type": "Vec<u8>"
            }
          ],
          "docs": [
            " Same as `note_imminent_preimage` but origin is `OperationalPreimageOrigin`."
          ],
          "look_up": "0a11"
        },
        {
          "name": "reap_preimage",
          "args": [
            {
              "name": "proposal_hash",
              "type": "T::Hash"
            },
            {
              "name": "proposal_len_upper_bound",
              "type": "Compact<u32>"
            }
          ],
          "docs": [
            " Remove an expired proposal preimage and collect the deposit.",
            "",
            " The dispatch origin of this call must be _Signed_.",
            "",
            " - `proposal_hash`: The preimage hash of a proposal.",
            " - `proposal_length_upper_bound`: an upper bound on length of the proposal.",
            "   Extrinsic is weighted according to this value with no refund.",
            "",
            " This will only work after `VotingPeriod` blocks from the time that the preimage was",
            " noted, if it's the same account doing it. If it's a different account, then it'll only",
            " work an additional `EnactmentPeriod` later.",
            "",
            " Emits `PreimageReaped`.",
            "",
            " # <weight>",
            " - Complexity: `O(D)` where D is length of proposal.",
            " - Db reads: `Preimages`, provider account data",
            " - Db writes: `Preimages` provider account data",
            " # <\/weight>"
          ],
          "look_up": "0a12"
        },
        {
          "name": "unlock",
          "args": [
            {
              "name": "target",
              "type": "T::AccountId"
            }
          ],
          "docs": [
            " Unlock tokens that have an expired lock.",
            "",
            " The dispatch origin of this call must be _Signed_.",
            "",
            " - `target`: The account to remove the lock on.",
            "",
            " # <weight>",
            " - Complexity `O(R)` with R number of vote of target.",
            " - Db reads: `VotingOf`, `balances locks`, `target account`",
            " - Db writes: `VotingOf`, `balances locks`, `target account`",
            " # <\/weight>"
          ],
          "look_up": "0a13"
        },
        {
          "name": "remove_vote",
          "args": [
            {
              "name": "index",
              "type": "ReferendumIndex"
            }
          ],
          "docs": [
            " Remove a vote for a referendum.",
            "",
            " If:",
            " - the referendum was cancelled, or",
            " - the referendum is ongoing, or",
            " - the referendum has ended such that",
            "   - the vote of the account was in opposition to the result; or",
            "   - there was no conviction to the account's vote; or",
            "   - the account made a split vote",
            " ...then the vote is removed cleanly and a following call to `unlock` may result in more",
            " funds being available.",
            "",
            " If, however, the referendum has ended and:",
            " - it finished corresponding to the vote of the account, and",
            " - the account made a standard vote with conviction, and",
            " - the lock period of the conviction is not over",
            " ...then the lock will be aggregated into the overall account's lock, which may involve",
            " *overlocking* (where the two locks are combined into a single lock that is the maximum",
            " of both the amount locked and the time is it locked for).",
            "",
            " The dispatch origin of this call must be _Signed_, and the signer must have a vote",
            " registered for referendum `index`.",
            "",
            " - `index`: The index of referendum of the vote to be removed.",
            "",
            " # <weight>",
            " - `O(R + log R)` where R is the number of referenda that `target` has voted on.",
            "   Weight is calculated for the maximum number of vote.",
            " - Db reads: `ReferendumInfoOf`, `VotingOf`",
            " - Db writes: `ReferendumInfoOf`, `VotingOf`",
            " # <\/weight>"
          ],
          "look_up": "0a14"
        },
        {
          "name": "remove_other_vote",
          "args": [
            {
              "name": "target",
              "type": "T::AccountId"
            },
            {
              "name": "index",
              "type": "ReferendumIndex"
            }
          ],
          "docs": [
            " Remove a vote for a referendum.",
            "",
            " If the `target` is equal to the signer, then this function is exactly equivalent to",
            " `remove_vote`. If not equal to the signer, then the vote must have expired,",
            " either because the referendum was cancelled, because the voter lost the referendum or",
            " because the conviction period is over.",
            "",
            " The dispatch origin of this call must be _Signed_.",
            "",
            " - `target`: The account of the vote to be removed; this account must have voted for",
            "   referendum `index`.",
            " - `index`: The index of referendum of the vote to be removed.",
            "",
            " # <weight>",
            " - `O(R + log R)` where R is the number of referenda that `target` has voted on.",
            "   Weight is calculated for the maximum number of vote.",
            " - Db reads: `ReferendumInfoOf`, `VotingOf`",
            " - Db writes: `ReferendumInfoOf`, `VotingOf`",
            " # <\/weight>"
          ],
          "look_up": "0a15"
        },
        {
          "name": "enact_proposal",
          "args": [
            {
              "name": "proposal_hash",
              "type": "T::Hash"
            },
            {
              "name": "index",
              "type": "ReferendumIndex"
            }
          ],
          "docs": [
            " Enact a proposal from a referendum. For now we just make the weight be the maximum."
          ],
          "look_up": "0a16"
        }
      ],
      "events": [
        {
          "name": "Proposed",
          "args": [
            "PropIndex",
            "Balance"
          ],
          "docs": [
            " A motion has been proposed by a public account. [proposal_index, deposit]"
          ],
          "look_up": "0a00"
        },
        {
          "name": "Tabled",
          "args": [
            "PropIndex",
            "Balance",
            "Vec<AccountId>"
          ],
          "docs": [
            " A public proposal has been tabled for referendum vote. [proposal_index, deposit, depositors]"
          ],
          "look_up": "0a01"
        },
        {
          "name": "ExternalTabled",
          "args": [],
          "docs": [
            " An external proposal has been tabled."
          ],
          "look_up": "0a02"
        },
        {
          "name": "Started",
          "args": [
            "ReferendumIndex",
            "VoteThreshold"
          ],
          "docs": [
            " A referendum has begun. [ref_index, threshold]"
          ],
          "look_up": "0a03"
        },
        {
          "name": "Passed",
          "args": [
            "ReferendumIndex"
          ],
          "docs": [
            " A proposal has been approved by referendum. [ref_index]"
          ],
          "look_up": "0a04"
        },
        {
          "name": "NotPassed",
          "args": [
            "ReferendumIndex"
          ],
          "docs": [
            " A proposal has been rejected by referendum. [ref_index]"
          ],
          "look_up": "0a05"
        },
        {
          "name": "Cancelled",
          "args": [
            "ReferendumIndex"
          ],
          "docs": [
            " A referendum has been cancelled. [ref_index]"
          ],
          "look_up": "0a06"
        },
        {
          "name": "Executed",
          "args": [
            "ReferendumIndex",
            "bool"
          ],
          "docs": [
            " A proposal has been enacted. [ref_index, is_ok]"
          ],
          "look_up": "0a07"
        },
        {
          "name": "Delegated",
          "args": [
            "AccountId",
            "AccountId"
          ],
          "docs": [
            " An account has delegated their vote to another account. [who, target]"
          ],
          "look_up": "0a08"
        },
        {
          "name": "Undelegated",
          "args": [
            "AccountId"
          ],
          "docs": [
            " An [account] has cancelled a previous delegation operation."
          ],
          "look_up": "0a09"
        },
        {
          "name": "Vetoed",
          "args": [
            "AccountId",
            "Hash",
            "BlockNumber"
          ],
          "docs": [
            " An external proposal has been vetoed. [who, proposal_hash, until]"
          ],
          "look_up": "0a0a"
        },
        {
          "name": "PreimageNoted",
          "args": [
            "Hash",
            "AccountId",
            "Balance"
          ],
          "docs": [
            " A proposal's preimage was noted, and the deposit taken. [proposal_hash, who, deposit]"
          ],
          "look_up": "0a0b"
        },
        {
          "name": "PreimageUsed",
          "args": [
            "Hash",
            "AccountId",
            "Balance"
          ],
          "docs": [
            " A proposal preimage was removed and used (the deposit was returned).",
            " [proposal_hash, provider, deposit]"
          ],
          "look_up": "0a0c"
        },
        {
          "name": "PreimageInvalid",
          "args": [
            "Hash",
            "ReferendumIndex"
          ],
          "docs": [
            " A proposal could not be executed because its preimage was invalid. [proposal_hash, ref_index]"
          ],
          "look_up": "0a0d"
        },
        {
          "name": "PreimageMissing",
          "args": [
            "Hash",
            "ReferendumIndex"
          ],
          "docs": [
            " A proposal could not be executed because its preimage was missing. [proposal_hash, ref_index]"
          ],
          "look_up": "0a0e"
        },
        {
          "name": "PreimageReaped",
          "args": [
            "Hash",
            "AccountId",
            "Balance",
            "AccountId"
          ],
          "docs": [
            " A registered preimage was removed and the deposit collected by the reaper.",
            " [proposal_hash, provider, deposit, reaper]"
          ],
          "look_up": "0a0f"
        },
        {
          "name": "Unlocked",
          "args": [
            "AccountId"
          ],
          "docs": [
            " An [account] has been unlocked successfully."
          ],
          "look_up": "0a10"
        }
      ],
      "errors": [
        {
          "name": "ValueLow",
          "docs": [
            " Value too low"
          ]
        },
        {
          "name": "ProposalMissing",
          "docs": [
            " Proposal does not exist"
          ]
        },
        {
          "name": "BadIndex",
          "docs": [
            " Unknown index"
          ]
        },
        {
          "name": "AlreadyCanceled",
          "docs": [
            " Cannot cancel the same proposal twice"
          ]
        },
        {
          "name": "DuplicateProposal",
          "docs": [
            " Proposal already made"
          ]
        },
        {
          "name": "ProposalBlacklisted",
          "docs": [
            " Proposal still blacklisted"
          ]
        },
        {
          "name": "NotSimpleMajority",
          "docs": [
            " Next external proposal not simple majority"
          ]
        },
        {
          "name": "InvalidHash",
          "docs": [
            " Invalid hash"
          ]
        },
        {
          "name": "NoProposal",
          "docs": [
            " No external proposal"
          ]
        },
        {
          "name": "AlreadyVetoed",
          "docs": [
            " Identity may not veto a proposal twice"
          ]
        },
        {
          "name": "NotDelegated",
          "docs": [
            " Not delegated"
          ]
        },
        {
          "name": "DuplicatePreimage",
          "docs": [
            " Preimage already noted"
          ]
        },
        {
          "name": "NotImminent",
          "docs": [
            " Not imminent"
          ]
        },
        {
          "name": "TooEarly",
          "docs": [
            " Too early"
          ]
        },
        {
          "name": "Imminent",
          "docs": [
            " Imminent"
          ]
        },
        {
          "name": "PreimageMissing",
          "docs": [
            " Preimage not found"
          ]
        },
        {
          "name": "ReferendumInvalid",
          "docs": [
            " Vote given for invalid referendum"
          ]
        },
        {
          "name": "PreimageInvalid",
          "docs": [
            " Invalid preimage"
          ]
        },
        {
          "name": "NoneWaiting",
          "docs": [
            " No proposals waiting"
          ]
        },
        {
          "name": "NotLocked",
          "docs": [
            " The target account does not have a lock."
          ]
        },
        {
          "name": "NotExpired",
          "docs": [
            " The lock on the account to be unlocked has not yet expired."
          ]
        },
        {
          "name": "NotVoter",
          "docs": [
            " The given account did not vote on the referendum."
          ]
        },
        {
          "name": "NoPermission",
          "docs": [
            " The actor has no permission to conduct the action."
          ]
        },
        {
          "name": "AlreadyDelegating",
          "docs": [
            " The account is already delegating."
          ]
        },
        {
          "name": "Overflow",
          "docs": [
            " An unexpected integer overflow occurred."
          ]
        },
        {
          "name": "Underflow",
          "docs": [
            " An unexpected integer underflow occurred."
          ]
        },
        {
          "name": "InsufficientFunds",
          "docs": [
            " Too high a balance was provided that the account cannot afford."
          ]
        },
        {
          "name": "NotDelegating",
          "docs": [
            " The account is not currently delegating."
          ]
        },
        {
          "name": "VotesExist",
          "docs": [
            " The account currently has votes attached to it and the operation cannot succeed until",
            " these are removed, either through `unvote` or `reap_vote`."
          ]
        },
        {
          "name": "InstantNotAllowed",
          "docs": [
            " The instant referendum origin is currently disallowed."
          ]
        },
        {
          "name": "Nonsense",
          "docs": [
            " Delegation to oneself makes no sense."
          ]
        },
        {
          "name": "WrongUpperBound",
          "docs": [
            " Invalid upper bound."
          ]
        },
        {
          "name": "MaxVotesReached",
          "docs": [
            " Maximum number of votes reached."
          ]
        }
      ],
      "constants": [
        {
          "name": "EnactmentPeriod",
          "type": "T::BlockNumber",
          "value": "002f0d00",
          "docs": [
            " The minimum period of locking and the period between a proposal being approved and enacted.",
            "",
            " It should generally be a little more than the unstake period to ensure that",
            " voting stakers have an opportunity to remove themselves from the system in the case where",
            " they are on the losing side of a vote."
          ]
        },
        {
          "name": "LaunchPeriod",
          "type": "T::BlockNumber",
          "value": "004e0c00",
          "docs": [
            " How often (in blocks) new public referenda are launched."
          ]
        },
        {
          "name": "VotingPeriod",
          "type": "T::BlockNumber",
          "value": "004e0c00",
          "docs": [
            " How often (in blocks) to check for new votes."
          ]
        },
        {
          "name": "MinimumDeposit",
          "type": "BalanceOf<T>",
          "value": "0000c16ff28623000000000000000000",
          "docs": [
            " The minimum amount to be used as a deposit for a public referendum proposal."
          ]
        },
        {
          "name": "FastTrackVotingPeriod",
          "type": "T::BlockNumber",
          "value": "80510100",
          "docs": [
            " Minimum voting period allowed for an emergency referendum."
          ]
        },
        {
          "name": "CooloffPeriod",
          "type": "T::BlockNumber",
          "value": "004e0c00",
          "docs": [
            " Period in blocks where an external proposal may not be re-submitted after being vetoed."
          ]
        },
        {
          "name": "PreimageByteDeposit",
          "type": "BalanceOf<T>",
          "value": "0010a5d4e80000000000000000000000",
          "docs": [
            " The amount of balance that must be deposited per byte of preimage stored."
          ]
        },
        {
          "name": "MaxVotes",
          "type": "u32",
          "value": "64000000",
          "docs": [
            " The maximum number of votes for an account."
          ]
        }
      ],
      "index": 10
    },
    {
      "name": "Council",
      "prefix": "Instance1Collective",
      "calls": [
        {
          "name": "set_members",
          "args": [
            {
              "name": "new_members",
              "type": "Vec<T::AccountId>"
            },
            {
              "name": "prime",
              "type": "Option<T::AccountId>"
            },
            {
              "name": "old_count",
              "type": "MemberCount"
            }
          ],
          "docs": [
            " Set the collective's membership.",
            "",
            " - `new_members`: The new member list. Be nice to the chain and provide it sorted.",
            " - `prime`: The prime member whose vote sets the default.",
            " - `old_count`: The upper bound for the previous number of members in storage.",
            "                Used for weight estimation.",
            "",
            " Requires root origin.",
            "",
            " NOTE: Does not enforce the expected `MaxMembers` limit on the amount of members, but",
            "       the weight estimations rely on it to estimate dispatchable weight.",
            "",
            " # <weight>",
            " ## Weight",
            " - `O(MP + N)` where:",
            "   - `M` old-members-count (code- and governance-bounded)",
            "   - `N` new-members-count (code- and governance-bounded)",
            "   - `P` proposals-count (code-bounded)",
            " - DB:",
            "   - 1 storage mutation (codec `O(M)` read, `O(N)` write) for reading and writing the members",
            "   - 1 storage read (codec `O(P)`) for reading the proposals",
            "   - `P` storage mutations (codec `O(M)`) for updating the votes for each proposal",
            "   - 1 storage write (codec `O(1)`) for deleting the old `prime` and setting the new one",
            " # <\/weight>"
          ],
          "look_up": "0b00"
        },
        {
          "name": "execute",
          "args": [
            {
              "name": "proposal",
              "type": "Box<<T as Trait<I>>::Proposal>"
            },
            {
              "name": "length_bound",
              "type": "Compact<u32>"
            }
          ],
          "docs": [
            " Dispatch a proposal from a member using the `Member` origin.",
            "",
            " Origin must be a member of the collective.",
            "",
            " # <weight>",
            " ## Weight",
            " - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching `proposal`",
            " - DB: 1 read (codec `O(M)`) + DB access of `proposal`",
            " - 1 event",
            " # <\/weight>"
          ],
          "look_up": "0b01"
        },
        {
          "name": "propose",
          "args": [
            {
              "name": "threshold",
              "type": "Compact<MemberCount>"
            },
            {
              "name": "proposal",
              "type": "Box<<T as Trait<I>>::Proposal>"
            },
            {
              "name": "length_bound",
              "type": "Compact<u32>"
            }
          ],
          "docs": [
            " Add a new proposal to either be voted on or executed directly.",
            "",
            " Requires the sender to be member.",
            "",
            " `threshold` determines whether `proposal` is executed directly (`threshold < 2`)",
            " or put up for voting.",
            "",
            " # <weight>",
            " ## Weight",
            " - `O(B + M + P1)` or `O(B + M + P2)` where:",
            "   - `B` is `proposal` size in bytes (length-fee-bounded)",
            "   - `M` is members-count (code- and governance-bounded)",
            "   - branching is influenced by `threshold` where:",
            "     - `P1` is proposal execution complexity (`threshold < 2`)",
            "     - `P2` is proposals-count (code-bounded) (`threshold >= 2`)",
            " - DB:",
            "   - 1 storage read `is_member` (codec `O(M)`)",
            "   - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)",
            "   - DB accesses influenced by `threshold`:",
            "     - EITHER storage accesses done by `proposal` (`threshold < 2`)",
            "     - OR proposal insertion (`threshold <= 2`)",
            "       - 1 storage mutation `Proposals` (codec `O(P2)`)",
            "       - 1 storage mutation `ProposalCount` (codec `O(1)`)",
            "       - 1 storage write `ProposalOf` (codec `O(B)`)",
            "       - 1 storage write `Voting` (codec `O(M)`)",
            "   - 1 event",
            " # <\/weight>"
          ],
          "look_up": "0b02"
        },
        {
          "name": "vote",
          "args": [
            {
              "name": "proposal",
              "type": "T::Hash"
            },
            {
              "name": "index",
              "type": "Compact<ProposalIndex>"
            },
            {
              "name": "approve",
              "type": "bool"
            }
          ],
          "docs": [
            " Add an aye or nay vote for the sender to the given proposal.",
            "",
            " Requires the sender to be a member.",
            "",
            " # <weight>",
            " ## Weight",
            " - `O(M)` where `M` is members-count (code- and governance-bounded)",
            " - DB:",
            "   - 1 storage read `Members` (codec `O(M)`)",
            "   - 1 storage mutation `Voting` (codec `O(M)`)",
            " - 1 event",
            " # <\/weight>"
          ],
          "look_up": "0b03"
        },
        {
          "name": "close",
          "args": [
            {
              "name": "proposal_hash",
              "type": "T::Hash"
            },
            {
              "name": "index",
              "type": "Compact<ProposalIndex>"
            },
            {
              "name": "proposal_weight_bound",
              "type": "Compact<Weight>"
            },
            {
              "name": "length_bound",
              "type": "Compact<u32>"
            }
          ],
          "docs": [
            " Close a vote that is either approved, disapproved or whose voting period has ended.",
            "",
            " May be called by any signed account in order to finish voting and close the proposal.",
            "",
            " If called before the end of the voting period it will only close the vote if it is",
            " has enough votes to be approved or disapproved.",
            "",
            " If called after the end of the voting period abstentions are counted as rejections",
            " unless there is a prime member set and the prime member cast an approval.",
            "",
            " + `proposal_weight_bound`: The maximum amount of weight consumed by executing the closed proposal.",
            " + `length_bound`: The upper bound for the length of the proposal in storage. Checked via",
            "                   `storage::read` so it is `size_of::<u32>() == 4` larger than the pure length.",
            "",
            " # <weight>",
            " ## Weight",
            " - `O(B + M + P1 + P2)` where:",
            "   - `B` is `proposal` size in bytes (length-fee-bounded)",
            "   - `M` is members-count (code- and governance-bounded)",
            "   - `P1` is the complexity of `proposal` preimage.",
            "   - `P2` is proposal-count (code-bounded)",
            " - DB:",
            "  - 2 storage reads (`Members`: codec `O(M)`, `Prime`: codec `O(1)`)",
            "  - 3 mutations (`Voting`: codec `O(M)`, `ProposalOf`: codec `O(B)`, `Proposals`: codec `O(P2)`)",
            "  - any mutations done while executing `proposal` (`P1`)",
            " - up to 3 events",
            " # <\/weight>"
          ],
          "look_up": "0b04"
        },
        {
          "name": "disapprove_proposal",
          "args": [
            {
              "name": "proposal_hash",
              "type": "T::Hash"
            }
          ],
          "docs": [
            " Disapprove a proposal, close, and remove it from the system, regardless of its current state.",
            "",
            " Must be called by the Root origin.",
            "",
            " Parameters:",
            " * `proposal_hash`: The hash of the proposal that should be disapproved.",
            "",
            " # <weight>",
            " Complexity: O(P) where P is the number of max proposals",
            " DB Weight:",
            " * Reads: Proposals",
            " * Writes: Voting, Proposals, ProposalOf",
            " # <\/weight>"
          ],
          "look_up": "0b05"
        }
      ],
      "events": [
        {
          "name": "Proposed",
          "args": [
            "AccountId",
            "ProposalIndex",
            "Hash",
            "MemberCount"
          ],
          "docs": [
            " A motion (given hash) has been proposed (by given account) with a threshold (given",
            " `MemberCount`).",
            " [account, proposal_index, proposal_hash, threshold]"
          ],
          "look_up": "0b00"
        },
        {
          "name": "Voted",
          "args": [
            "AccountId",
            "Hash",
            "bool",
            "MemberCount",
            "MemberCount"
          ],
          "docs": [
            " A motion (given hash) has been voted on by given account, leaving",
            " a tally (yes votes and no votes given respectively as `MemberCount`).",
            " [account, proposal_hash, voted, yes, no]"
          ],
          "look_up": "0b01"
        },
        {
          "name": "Approved",
          "args": [
            "Hash"
          ],
          "docs": [
            " A motion was approved by the required threshold.",
            " [proposal_hash]"
          ],
          "look_up": "0b02"
        },
        {
          "name": "Disapproved",
          "args": [
            "Hash"
          ],
          "docs": [
            " A motion was not approved by the required threshold.",
            " [proposal_hash]"
          ],
          "look_up": "0b03"
        },
        {
          "name": "Executed",
          "args": [
            "Hash",
            "DispatchResult"
          ],
          "docs": [
            " A motion was executed; result will be `Ok` if it returned without error.",
            " [proposal_hash, result]"
          ],
          "look_up": "0b04"
        },
        {
          "name": "MemberExecuted",
          "args": [
            "Hash",
            "DispatchResult"
          ],
          "docs": [
            " A single member did some action; result will be `Ok` if it returned without error.",
            " [proposal_hash, result]"
          ],
          "look_up": "0b05"
        },
        {
          "name": "Closed",
          "args": [
            "Hash",
            "MemberCount",
            "MemberCount"
          ],
          "docs": [
            " A proposal was closed because its threshold was reached or after its duration was up.",
            " [proposal_hash, yes, no]"
          ],
          "look_up": "0b06"
        }
      ],
      "errors": [
        {
          "name": "NotMember",
          "docs": [
            " Account is not a member"
          ]
        },
        {
          "name": "DuplicateProposal",
          "docs": [
            " Duplicate proposals not allowed"
          ]
        },
        {
          "name": "ProposalMissing",
          "docs": [
            " Proposal must exist"
          ]
        },
        {
          "name": "WrongIndex",
          "docs": [
            " Mismatched index"
          ]
        },
        {
          "name": "DuplicateVote",
          "docs": [
            " Duplicate vote ignored"
          ]
        },
        {
          "name": "AlreadyInitialized",
          "docs": [
            " Members are already initialized!"
          ]
        },
        {
          "name": "TooEarly",
          "docs": [
            " The close call was made too early, before the end of the voting."
          ]
        },
        {
          "name": "TooManyProposals",
          "docs": [
            " There can only be a maximum of `MaxProposals` active proposals."
          ]
        },
        {
          "name": "WrongProposalWeight",
          "docs": [
            " The given weight bound for the proposal was too low."
          ]
        },
        {
          "name": "WrongProposalLength",
          "docs": [
            " The given length bound for the proposal was too low."
          ]
        }
      ],
      "constants": [
        {
          "name": "EnactmentPeriod",
          "type": "T::BlockNumber",
          "value": "002f0d00",
          "docs": [
            " The minimum period of locking and the period between a proposal being approved and enacted.",
            "",
            " It should generally be a little more than the unstake period to ensure that",
            " voting stakers have an opportunity to remove themselves from the system in the case where",
            " they are on the losing side of a vote."
          ]
        },
        {
          "name": "LaunchPeriod",
          "type": "T::BlockNumber",
          "value": "004e0c00",
          "docs": [
            " How often (in blocks) new public referenda are launched."
          ]
        },
        {
          "name": "VotingPeriod",
          "type": "T::BlockNumber",
          "value": "004e0c00",
          "docs": [
            " How often (in blocks) to check for new votes."
          ]
        },
        {
          "name": "MinimumDeposit",
          "type": "BalanceOf<T>",
          "value": "0000c16ff28623000000000000000000",
          "docs": [
            " The minimum amount to be used as a deposit for a public referendum proposal."
          ]
        },
        {
          "name": "FastTrackVotingPeriod",
          "type": "T::BlockNumber",
          "value": "80510100",
          "docs": [
            " Minimum voting period allowed for an emergency referendum."
          ]
        },
        {
          "name": "CooloffPeriod",
          "type": "T::BlockNumber",
          "value": "004e0c00",
          "docs": [
            " Period in blocks where an external proposal may not be re-submitted after being vetoed."
          ]
        },
        {
          "name": "PreimageByteDeposit",
          "type": "BalanceOf<T>",
          "value": "0010a5d4e80000000000000000000000",
          "docs": [
            " The amount of balance that must be deposited per byte of preimage stored."
          ]
        },
        {
          "name": "MaxVotes",
          "type": "u32",
          "value": "64000000",
          "docs": [
            " The maximum number of votes for an account."
          ]
        }
      ],
      "index": 11
    },
    {
      "name": "TechnicalCommittee",
      "prefix": "Instance2Collective",
      "calls": [
        {
          "name": "set_members",
          "args": [
            {
              "name": "new_members",
              "type": "Vec<T::AccountId>"
            },
            {
              "name": "prime",
              "type": "Option<T::AccountId>"
            },
            {
              "name": "old_count",
              "type": "MemberCount"
            }
          ],
          "docs": [
            " Set the collective's membership.",
            "",
            " - `new_members`: The new member list. Be nice to the chain and provide it sorted.",
            " - `prime`: The prime member whose vote sets the default.",
            " - `old_count`: The upper bound for the previous number of members in storage.",
            "                Used for weight estimation.",
            "",
            " Requires root origin.",
            "",
            " NOTE: Does not enforce the expected `MaxMembers` limit on the amount of members, but",
            "       the weight estimations rely on it to estimate dispatchable weight.",
            "",
            " # <weight>",
            " ## Weight",
            " - `O(MP + N)` where:",
            "   - `M` old-members-count (code- and governance-bounded)",
            "   - `N` new-members-count (code- and governance-bounded)",
            "   - `P` proposals-count (code-bounded)",
            " - DB:",
            "   - 1 storage mutation (codec `O(M)` read, `O(N)` write) for reading and writing the members",
            "   - 1 storage read (codec `O(P)`) for reading the proposals",
            "   - `P` storage mutations (codec `O(M)`) for updating the votes for each proposal",
            "   - 1 storage write (codec `O(1)`) for deleting the old `prime` and setting the new one",
            " # <\/weight>"
          ],
          "look_up": "0c00"
        },
        {
          "name": "execute",
          "args": [
            {
              "name": "proposal",
              "type": "Box<<T as Trait<I>>::Proposal>"
            },
            {
              "name": "length_bound",
              "type": "Compact<u32>"
            }
          ],
          "docs": [
            " Dispatch a proposal from a member using the `Member` origin.",
            "",
            " Origin must be a member of the collective.",
            "",
            " # <weight>",
            " ## Weight",
            " - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching `proposal`",
            " - DB: 1 read (codec `O(M)`) + DB access of `proposal`",
            " - 1 event",
            " # <\/weight>"
          ],
          "look_up": "0c01"
        },
        {
          "name": "propose",
          "args": [
            {
              "name": "threshold",
              "type": "Compact<MemberCount>"
            },
            {
              "name": "proposal",
              "type": "Box<<T as Trait<I>>::Proposal>"
            },
            {
              "name": "length_bound",
              "type": "Compact<u32>"
            }
          ],
          "docs": [
            " Add a new proposal to either be voted on or executed directly.",
            "",
            " Requires the sender to be member.",
            "",
            " `threshold` determines whether `proposal` is executed directly (`threshold < 2`)",
            " or put up for voting.",
            "",
            " # <weight>",
            " ## Weight",
            " - `O(B + M + P1)` or `O(B + M + P2)` where:",
            "   - `B` is `proposal` size in bytes (length-fee-bounded)",
            "   - `M` is members-count (code- and governance-bounded)",
            "   - branching is influenced by `threshold` where:",
            "     - `P1` is proposal execution complexity (`threshold < 2`)",
            "     - `P2` is proposals-count (code-bounded) (`threshold >= 2`)",
            " - DB:",
            "   - 1 storage read `is_member` (codec `O(M)`)",
            "   - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)",
            "   - DB accesses influenced by `threshold`:",
            "     - EITHER storage accesses done by `proposal` (`threshold < 2`)",
            "     - OR proposal insertion (`threshold <= 2`)",
            "       - 1 storage mutation `Proposals` (codec `O(P2)`)",
            "       - 1 storage mutation `ProposalCount` (codec `O(1)`)",
            "       - 1 storage write `ProposalOf` (codec `O(B)`)",
            "       - 1 storage write `Voting` (codec `O(M)`)",
            "   - 1 event",
            " # <\/weight>"
          ],
          "look_up": "0c02"
        },
        {
          "name": "vote",
          "args": [
            {
              "name": "proposal",
              "type": "T::Hash"
            },
            {
              "name": "index",
              "type": "Compact<ProposalIndex>"
            },
            {
              "name": "approve",
              "type": "bool"
            }
          ],
          "docs": [
            " Add an aye or nay vote for the sender to the given proposal.",
            "",
            " Requires the sender to be a member.",
            "",
            " # <weight>",
            " ## Weight",
            " - `O(M)` where `M` is members-count (code- and governance-bounded)",
            " - DB:",
            "   - 1 storage read `Members` (codec `O(M)`)",
            "   - 1 storage mutation `Voting` (codec `O(M)`)",
            " - 1 event",
            " # <\/weight>"
          ],
          "look_up": "0c03"
        },
        {
          "name": "close",
          "args": [
            {
              "name": "proposal_hash",
              "type": "T::Hash"
            },
            {
              "name": "index",
              "type": "Compact<ProposalIndex>"
            },
            {
              "name": "proposal_weight_bound",
              "type": "Compact<Weight>"
            },
            {
              "name": "length_bound",
              "type": "Compact<u32>"
            }
          ],
          "docs": [
            " Close a vote that is either approved, disapproved or whose voting period has ended.",
            "",
            " May be called by any signed account in order to finish voting and close the proposal.",
            "",
            " If called before the end of the voting period it will only close the vote if it is",
            " has enough votes to be approved or disapproved.",
            "",
            " If called after the end of the voting period abstentions are counted as rejections",
            " unless there is a prime member set and the prime member cast an approval.",
            "",
            " + `proposal_weight_bound`: The maximum amount of weight consumed by executing the closed proposal.",
            " + `length_bound`: The upper bound for the length of the proposal in storage. Checked via",
            "                   `storage::read` so it is `size_of::<u32>() == 4` larger than the pure length.",
            "",
            " # <weight>",
            " ## Weight",
            " - `O(B + M + P1 + P2)` where:",
            "   - `B` is `proposal` size in bytes (length-fee-bounded)",
            "   - `M` is members-count (code- and governance-bounded)",
            "   - `P1` is the complexity of `proposal` preimage.",
            "   - `P2` is proposal-count (code-bounded)",
            " - DB:",
            "  - 2 storage reads (`Members`: codec `O(M)`, `Prime`: codec `O(1)`)",
            "  - 3 mutations (`Voting`: codec `O(M)`, `ProposalOf`: codec `O(B)`, `Proposals`: codec `O(P2)`)",
            "  - any mutations done while executing `proposal` (`P1`)",
            " - up to 3 events",
            " # <\/weight>"
          ],
          "look_up": "0c04"
        },
        {
          "name": "disapprove_proposal",
          "args": [
            {
              "name": "proposal_hash",
              "type": "T::Hash"
            }
          ],
          "docs": [
            " Disapprove a proposal, close, and remove it from the system, regardless of its current state.",
            "",
            " Must be called by the Root origin.",
            "",
            " Parameters:",
            " * `proposal_hash`: The hash of the proposal that should be disapproved.",
            "",
            " # <weight>",
            " Complexity: O(P) where P is the number of max proposals",
            " DB Weight:",
            " * Reads: Proposals",
            " * Writes: Voting, Proposals, ProposalOf",
            " # <\/weight>"
          ],
          "look_up": "0c05"
        }
      ],
      "events": [
        {
          "name": "Proposed",
          "args": [
            "AccountId",
            "ProposalIndex",
            "Hash",
            "MemberCount"
          ],
          "docs": [
            " A motion (given hash) has been proposed (by given account) with a threshold (given",
            " `MemberCount`).",
            " [account, proposal_index, proposal_hash, threshold]"
          ],
          "look_up": "0c00"
        },
        {
          "name": "Voted",
          "args": [
            "AccountId",
            "Hash",
            "bool",
            "MemberCount",
            "MemberCount"
          ],
          "docs": [
            " A motion (given hash) has been voted on by given account, leaving",
            " a tally (yes votes and no votes given respectively as `MemberCount`).",
            " [account, proposal_hash, voted, yes, no]"
          ],
          "look_up": "0c01"
        },
        {
          "name": "Approved",
          "args": [
            "Hash"
          ],
          "docs": [
            " A motion was approved by the required threshold.",
            " [proposal_hash]"
          ],
          "look_up": "0c02"
        },
        {
          "name": "Disapproved",
          "args": [
            "Hash"
          ],
          "docs": [
            " A motion was not approved by the required threshold.",
            " [proposal_hash]"
          ],
          "look_up": "0c03"
        },
        {
          "name": "Executed",
          "args": [
            "Hash",
            "DispatchResult"
          ],
          "docs": [
            " A motion was executed; result will be `Ok` if it returned without error.",
            " [proposal_hash, result]"
          ],
          "look_up": "0c04"
        },
        {
          "name": "MemberExecuted",
          "args": [
            "Hash",
            "DispatchResult"
          ],
          "docs": [
            " A single member did some action; result will be `Ok` if it returned without error.",
            " [proposal_hash, result]"
          ],
          "look_up": "0c05"
        },
        {
          "name": "Closed",
          "args": [
            "Hash",
            "MemberCount",
            "MemberCount"
          ],
          "docs": [
            " A proposal was closed because its threshold was reached or after its duration was up.",
            " [proposal_hash, yes, no]"
          ],
          "look_up": "0c06"
        }
      ],
      "errors": [
        {
          "name": "NotMember",
          "docs": [
            " Account is not a member"
          ]
        },
        {
          "name": "DuplicateProposal",
          "docs": [
            " Duplicate proposals not allowed"
          ]
        },
        {
          "name": "ProposalMissing",
          "docs": [
            " Proposal must exist"
          ]
        },
        {
          "name": "WrongIndex",
          "docs": [
            " Mismatched index"
          ]
        },
        {
          "name": "DuplicateVote",
          "docs": [
            " Duplicate vote ignored"
          ]
        },
        {
          "name": "AlreadyInitialized",
          "docs": [
            " Members are already initialized!"
          ]
        },
        {
          "name": "TooEarly",
          "docs": [
            " The close call was made too early, before the end of the voting."
          ]
        },
        {
          "name": "TooManyProposals",
          "docs": [
            " There can only be a maximum of `MaxProposals` active proposals."
          ]
        },
        {
          "name": "WrongProposalWeight",
          "docs": [
            " The given weight bound for the proposal was too low."
          ]
        },
        {
          "name": "WrongProposalLength",
          "docs": [
            " The given length bound for the proposal was too low."
          ]
        }
      ],
      "constants": [
        {
          "name": "EnactmentPeriod",
          "type": "T::BlockNumber",
          "value": "002f0d00",
          "docs": [
            " The minimum period of locking and the period between a proposal being approved and enacted.",
            "",
            " It should generally be a little more than the unstake period to ensure that",
            " voting stakers have an opportunity to remove themselves from the system in the case where",
            " they are on the losing side of a vote."
          ]
        },
        {
          "name": "LaunchPeriod",
          "type": "T::BlockNumber",
          "value": "004e0c00",
          "docs": [
            " How often (in blocks) new public referenda are launched."
          ]
        },
        {
          "name": "VotingPeriod",
          "type": "T::BlockNumber",
          "value": "004e0c00",
          "docs": [
            " How often (in blocks) to check for new votes."
          ]
        },
        {
          "name": "MinimumDeposit",
          "type": "BalanceOf<T>",
          "value": "0000c16ff28623000000000000000000",
          "docs": [
            " The minimum amount to be used as a deposit for a public referendum proposal."
          ]
        },
        {
          "name": "FastTrackVotingPeriod",
          "type": "T::BlockNumber",
          "value": "80510100",
          "docs": [
            " Minimum voting period allowed for an emergency referendum."
          ]
        },
        {
          "name": "CooloffPeriod",
          "type": "T::BlockNumber",
          "value": "004e0c00",
          "docs": [
            " Period in blocks where an external proposal may not be re-submitted after being vetoed."
          ]
        },
        {
          "name": "PreimageByteDeposit",
          "type": "BalanceOf<T>",
          "value": "0010a5d4e80000000000000000000000",
          "docs": [
            " The amount of balance that must be deposited per byte of preimage stored."
          ]
        },
        {
          "name": "MaxVotes",
          "type": "u32",
          "value": "64000000",
          "docs": [
            " The maximum number of votes for an account."
          ]
        }
      ],
      "index": 12
    },
    {
      "name": "Elections",
      "prefix": "PhragmenElection",
      "calls": [
        {
          "name": "vote",
          "args": [
            {
              "name": "votes",
              "type": "Vec<T::AccountId>"
            },
            {
              "name": "value",
              "type": "Compact<BalanceOf<T>>"
            }
          ],
          "docs": [
            " Vote for a set of candidates for the upcoming round of election. This can be called to",
            " set the initial votes, or update already existing votes.",
            "",
            " Upon initial voting, `value` units of `who`'s balance is locked and a bond amount is",
            " reserved.",
            "",
            " The `votes` should:",
            "   - not be empty.",
            "   - be less than the number of possible candidates. Note that all current members and",
            "     runners-up are also automatically candidates for the next round.",
            "",
            " It is the responsibility of the caller to not place all of their balance into the lock",
            " and keep some for further transactions.",
            "",
            " # <weight>",
            " Base weight: 47.93 \u00b5s",
            " State reads:",
            " \t- Candidates.len() + Members.len() + RunnersUp.len()",
            " \t- Voting (is_voter)",
            " \t- [AccountBalance(who) (unreserve + total_balance)]",
            " State writes:",
            " \t- Voting",
            " \t- Lock",
            " \t- [AccountBalance(who) (unreserve -- only when creating a new voter)]",
            " # <\/weight>"
          ],
          "look_up": "0d00"
        },
        {
          "name": "remove_voter",
          "args": [],
          "docs": [
            " Remove `origin` as a voter. This removes the lock and returns the bond.",
            "",
            " # <weight>",
            " Base weight: 36.8 \u00b5s",
            " All state access is from do_remove_voter.",
            " State reads:",
            " \t- Voting",
            " \t- [AccountData(who)]",
            " State writes:",
            " \t- Voting",
            " \t- Locks",
            " \t- [AccountData(who)]",
            " # <\/weight>"
          ],
          "look_up": "0d01"
        },
        {
          "name": "report_defunct_voter",
          "args": [
            {
              "name": "defunct",
              "type": "DefunctVoter<<T::Lookup as StaticLookup>::Source>"
            }
          ],
          "docs": [
            " Report `target` for being an defunct voter. In case of a valid report, the reporter is",
            " rewarded by the bond amount of `target`. Otherwise, the reporter itself is removed and",
            " their bond is slashed.",
            "",
            " A defunct voter is defined to be:",
            "   - a voter whose current submitted votes are all invalid. i.e. all of them are no",
            "     longer a candidate nor an active member or a runner-up.",
            "",
            "",
            " The origin must provide the number of current candidates and votes of the reported target",
            " for the purpose of accurate weight calculation.",
            "",
            " # <weight>",
            " No Base weight based on min square analysis.",
            " Complexity of candidate_count: 1.755 \u00b5s",
            " Complexity of vote_count: 18.51 \u00b5s",
            " State reads:",
            "  \t- Voting(reporter)",
            "  \t- Candidate.len()",
            "  \t- Voting(Target)",
            "  \t- Candidates, Members, RunnersUp (is_defunct_voter)",
            " State writes:",
            " \t- Lock(reporter || target)",
            " \t- [AccountBalance(reporter)] + AccountBalance(target)",
            " \t- Voting(reporter || target)",
            " Note: the db access is worse with respect to db, which is when the report is correct.",
            " # <\/weight>"
          ],
          "look_up": "0d02"
        },
        {
          "name": "submit_candidacy",
          "args": [
            {
              "name": "candidate_count",
              "type": "Compact<u32>"
            }
          ],
          "docs": [
            " Submit oneself for candidacy.",
            "",
            " A candidate will either:",
            "   - Lose at the end of the term and forfeit their deposit.",
            "   - Win and become a member. Members will eventually get their stash back.",
            "   - Become a runner-up. Runners-ups are reserved members in case one gets forcefully",
            "     removed.",
            "",
            " # <weight>",
            " Base weight = 33.33 \u00b5s",
            " Complexity of candidate_count: 0.375 \u00b5s",
            " State reads:",
            " \t- Candidates.len()",
            " \t- Candidates",
            " \t- Members",
            " \t- RunnersUp",
            " \t- [AccountBalance(who)]",
            " State writes:",
            " \t- [AccountBalance(who)]",
            " \t- Candidates",
            " # <\/weight>"
          ],
          "look_up": "0d03"
        },
        {
          "name": "renounce_candidacy",
          "args": [
            {
              "name": "renouncing",
              "type": "Renouncing"
            }
          ],
          "docs": [
            " Renounce one's intention to be a candidate for the next election round. 3 potential",
            " outcomes exist:",
            " - `origin` is a candidate and not elected in any set. In this case, the bond is",
            "   unreserved, returned and origin is removed as a candidate.",
            " - `origin` is a current runner-up. In this case, the bond is unreserved, returned and",
            "   origin is removed as a runner-up.",
            " - `origin` is a current member. In this case, the bond is unreserved and origin is",
            "   removed as a member, consequently not being a candidate for the next round anymore.",
            "   Similar to [`remove_voter`], if replacement runners exists, they are immediately used.",
            " <weight>",
            " If a candidate is renouncing:",
            " \tBase weight: 17.28 \u00b5s",
            " \tComplexity of candidate_count: 0.235 \u00b5s",
            " \tState reads:",
            " \t\t- Candidates",
            " \t\t- [AccountBalance(who) (unreserve)]",
            " \tState writes:",
            " \t\t- Candidates",
            " \t\t- [AccountBalance(who) (unreserve)]",
            " If member is renouncing:",
            " \tBase weight: 46.25 \u00b5s",
            " \tState reads:",
            " \t\t- Members, RunnersUp (remove_and_replace_member),",
            " \t\t- [AccountData(who) (unreserve)]",
            " \tState writes:",
            " \t\t- Members, RunnersUp (remove_and_replace_member),",
            " \t\t- [AccountData(who) (unreserve)]",
            " If runner is renouncing:",
            " \tBase weight: 46.25 \u00b5s",
            " \tState reads:",
            " \t\t- RunnersUp (remove_and_replace_member),",
            " \t\t- [AccountData(who) (unreserve)]",
            " \tState writes:",
            " \t\t- RunnersUp (remove_and_replace_member),",
            " \t\t- [AccountData(who) (unreserve)]",
            "",
            " Weight note: The call into changeMembers need to be accounted for.",
            " <\/weight>"
          ],
          "look_up": "0d04"
        },
        {
          "name": "remove_member",
          "args": [
            {
              "name": "who",
              "type": "<T::Lookup as StaticLookup>::Source"
            },
            {
              "name": "has_replacement",
              "type": "bool"
            }
          ],
          "docs": [
            " Remove a particular member from the set. This is effective immediately and the bond of",
            " the outgoing member is slashed.",
            "",
            " If a runner-up is available, then the best runner-up will be removed and replaces the",
            " outgoing member. Otherwise, a new phragmen election is started.",
            "",
            " Note that this does not affect the designated block number of the next election.",
            "",
            " # <weight>",
            " If we have a replacement:",
            " \t- Base weight: 50.93 \u00b5s",
            " \t- State reads:",
            " \t\t- RunnersUp.len()",
            " \t\t- Members, RunnersUp (remove_and_replace_member)",
            " \t- State writes:",
            " \t\t- Members, RunnersUp (remove_and_replace_member)",
            " Else, since this is a root call and will go into phragmen, we assume full block for now.",
            " # <\/weight>"
          ],
          "look_up": "0d05"
        }
      ],
      "events": [
        {
          "name": "NewTerm",
          "args": [
            "Vec<(AccountId, Balance)>"
          ],
          "docs": [
            " A new term with [new_members]. This indicates that enough candidates existed to run the",
            " election, not that enough have has been elected. The inner value must be examined for",
            " this purpose. A `NewTerm([])` indicates that some candidates got their bond slashed and",
            " none were elected, whilst `EmptyTerm` means that no candidates existed to begin with."
          ],
          "look_up": "0d00"
        },
        {
          "name": "EmptyTerm",
          "args": [],
          "docs": [
            " No (or not enough) candidates existed for this round. This is different from",
            " `NewTerm([])`. See the description of `NewTerm`."
          ],
          "look_up": "0d01"
        },
        {
          "name": "MemberKicked",
          "args": [
            "AccountId"
          ],
          "docs": [
            " A [member] has been removed. This should always be followed by either `NewTerm` ot",
            " `EmptyTerm`."
          ],
          "look_up": "0d02"
        },
        {
          "name": "MemberRenounced",
          "args": [
            "AccountId"
          ],
          "docs": [
            " A [member] has renounced their candidacy."
          ],
          "look_up": "0d03"
        },
        {
          "name": "VoterReported",
          "args": [
            "AccountId",
            "AccountId",
            "bool"
          ],
          "docs": [
            " A voter was reported with the the report being successful or not.",
            " [voter, reporter, success]"
          ],
          "look_up": "0d04"
        }
      ],
      "errors": [
        {
          "name": "UnableToVote",
          "docs": [
            " Cannot vote when no candidates or members exist."
          ]
        },
        {
          "name": "NoVotes",
          "docs": [
            " Must vote for at least one candidate."
          ]
        },
        {
          "name": "TooManyVotes",
          "docs": [
            " Cannot vote more than candidates."
          ]
        },
        {
          "name": "MaximumVotesExceeded",
          "docs": [
            " Cannot vote more than maximum allowed."
          ]
        },
        {
          "name": "LowBalance",
          "docs": [
            " Cannot vote with stake less than minimum balance."
          ]
        },
        {
          "name": "UnableToPayBond",
          "docs": [
            " Voter can not pay voting bond."
          ]
        },
        {
          "name": "MustBeVoter",
          "docs": [
            " Must be a voter."
          ]
        },
        {
          "name": "ReportSelf",
          "docs": [
            " Cannot report self."
          ]
        },
        {
          "name": "DuplicatedCandidate",
          "docs": [
            " Duplicated candidate submission."
          ]
        },
        {
          "name": "MemberSubmit",
          "docs": [
            " Member cannot re-submit candidacy."
          ]
        },
        {
          "name": "RunnerSubmit",
          "docs": [
            " Runner cannot re-submit candidacy."
          ]
        },
        {
          "name": "InsufficientCandidateFunds",
          "docs": [
            " Candidate does not have enough funds."
          ]
        },
        {
          "name": "NotMember",
          "docs": [
            " Not a member."
          ]
        },
        {
          "name": "InvalidCandidateCount",
          "docs": [
            " The provided count of number of candidates is incorrect."
          ]
        },
        {
          "name": "InvalidVoteCount",
          "docs": [
            " The provided count of number of votes is incorrect."
          ]
        },
        {
          "name": "InvalidRenouncing",
          "docs": [
            " The renouncing origin presented a wrong `Renouncing` parameter."
          ]
        },
        {
          "name": "InvalidReplacement",
          "docs": [
            " Prediction regarding replacement after member removal is wrong."
          ]
        }
      ],
      "constants": [
        {
          "name": "CandidacyBond",
          "type": "BalanceOf<T>",
          "value": "0080c6a47e8d03000000000000000000",
          "docs": []
        },
        {
          "name": "VotingBond",
          "type": "BalanceOf<T>",
          "value": "00407a10f35a00000000000000000000",
          "docs": []
        },
        {
          "name": "DesiredMembers",
          "type": "u32",
          "value": "0d000000",
          "docs": []
        },
        {
          "name": "DesiredRunnersUp",
          "type": "u32",
          "value": "07000000",
          "docs": []
        },
        {
          "name": "TermDuration",
          "type": "T::BlockNumber",
          "value": "80130300",
          "docs": []
        },
        {
          "name": "ModuleId",
          "type": "LockIdentifier",
          "value": "706872656c656374",
          "docs": []
        }
      ],
      "index": 13
    },
    {
      "name": "TechnicalMembership",
      "prefix": "Instance1Membership",
      "calls": [
        {
          "name": "add_member",
          "args": [
            {
              "name": "who",
              "type": "T::AccountId"
            }
          ],
          "docs": [
            " Add a member `who` to the set.",
            "",
            " May only be called from `T::AddOrigin`."
          ],
          "look_up": "0e00"
        },
        {
          "name": "remove_member",
          "args": [
            {
              "name": "who",
              "type": "T::AccountId"
            }
          ],
          "docs": [
            " Remove a member `who` from the set.",
            "",
            " May only be called from `T::RemoveOrigin`."
          ],
          "look_up": "0e01"
        },
        {
          "name": "swap_member",
          "args": [
            {
              "name": "remove",
              "type": "T::AccountId"
            },
            {
              "name": "add",
              "type": "T::AccountId"
            }
          ],
          "docs": [
            " Swap out one member `remove` for another `add`.",
            "",
            " May only be called from `T::SwapOrigin`.",
            "",
            " Prime membership is *not* passed from `remove` to `add`, if extant."
          ],
          "look_up": "0e02"
        },
        {
          "name": "reset_members",
          "args": [
            {
              "name": "members",
              "type": "Vec<T::AccountId>"
            }
          ],
          "docs": [
            " Change the membership to a new set, disregarding the existing membership. Be nice and",
            " pass `members` pre-sorted.",
            "",
            " May only be called from `T::ResetOrigin`."
          ],
          "look_up": "0e03"
        },
        {
          "name": "change_key",
          "args": [
            {
              "name": "new",
              "type": "T::AccountId"
            }
          ],
          "docs": [
            " Swap out the sending member for some other key `new`.",
            "",
            " May only be called from `Signed` origin of a current member.",
            "",
            " Prime membership is passed from the origin account to `new`, if extant."
          ],
          "look_up": "0e04"
        },
        {
          "name": "set_prime",
          "args": [
            {
              "name": "who",
              "type": "T::AccountId"
            }
          ],
          "docs": [
            " Set the prime member. Must be a current member.",
            "",
            " May only be called from `T::PrimeOrigin`."
          ],
          "look_up": "0e05"
        },
        {
          "name": "clear_prime",
          "args": [],
          "docs": [
            " Remove the prime member if it exists.",
            "",
            " May only be called from `T::PrimeOrigin`."
          ],
          "look_up": "0e06"
        }
      ],
      "events": [
        {
          "name": "MemberAdded",
          "args": [],
          "docs": [
            " The given member was added; see the transaction for who."
          ],
          "look_up": "0e00"
        },
        {
          "name": "MemberRemoved",
          "args": [],
          "docs": [
            " The given member was removed; see the transaction for who."
          ],
          "look_up": "0e01"
        },
        {
          "name": "MembersSwapped",
          "args": [],
          "docs": [
            " Two members were swapped; see the transaction for who."
          ],
          "look_up": "0e02"
        },
        {
          "name": "MembersReset",
          "args": [],
          "docs": [
            " The membership was reset; see the transaction for who the new set is."
          ],
          "look_up": "0e03"
        },
        {
          "name": "KeyChanged",
          "args": [],
          "docs": [
            " One of the members' keys changed."
          ],
          "look_up": "0e04"
        },
        {
          "name": "Dummy",
          "args": [
            "sp_std::marker::PhantomData<(AccountId, Event)>"
          ],
          "docs": [
            " Phantom member, never used."
          ],
          "look_up": "0e05"
        }
      ],
      "errors": [
        {
          "name": "UnableToVote",
          "docs": [
            " Cannot vote when no candidates or members exist."
          ]
        },
        {
          "name": "NoVotes",
          "docs": [
            " Must vote for at least one candidate."
          ]
        },
        {
          "name": "TooManyVotes",
          "docs": [
            " Cannot vote more than candidates."
          ]
        },
        {
          "name": "MaximumVotesExceeded",
          "docs": [
            " Cannot vote more than maximum allowed."
          ]
        },
        {
          "name": "LowBalance",
          "docs": [
            " Cannot vote with stake less than minimum balance."
          ]
        },
        {
          "name": "UnableToPayBond",
          "docs": [
            " Voter can not pay voting bond."
          ]
        },
        {
          "name": "MustBeVoter",
          "docs": [
            " Must be a voter."
          ]
        },
        {
          "name": "ReportSelf",
          "docs": [
            " Cannot report self."
          ]
        },
        {
          "name": "DuplicatedCandidate",
          "docs": [
            " Duplicated candidate submission."
          ]
        },
        {
          "name": "MemberSubmit",
          "docs": [
            " Member cannot re-submit candidacy."
          ]
        },
        {
          "name": "RunnerSubmit",
          "docs": [
            " Runner cannot re-submit candidacy."
          ]
        },
        {
          "name": "InsufficientCandidateFunds",
          "docs": [
            " Candidate does not have enough funds."
          ]
        },
        {
          "name": "NotMember",
          "docs": [
            " Not a member."
          ]
        },
        {
          "name": "InvalidCandidateCount",
          "docs": [
            " The provided count of number of candidates is incorrect."
          ]
        },
        {
          "name": "InvalidVoteCount",
          "docs": [
            " The provided count of number of votes is incorrect."
          ]
        },
        {
          "name": "InvalidRenouncing",
          "docs": [
            " The renouncing origin presented a wrong `Renouncing` parameter."
          ]
        },
        {
          "name": "InvalidReplacement",
          "docs": [
            " Prediction regarding replacement after member removal is wrong."
          ]
        }
      ],
      "constants": [
        {
          "name": "CandidacyBond",
          "type": "BalanceOf<T>",
          "value": "0080c6a47e8d03000000000000000000",
          "docs": []
        },
        {
          "name": "VotingBond",
          "type": "BalanceOf<T>",
          "value": "00407a10f35a00000000000000000000",
          "docs": []
        },
        {
          "name": "DesiredMembers",
          "type": "u32",
          "value": "0d000000",
          "docs": []
        },
        {
          "name": "DesiredRunnersUp",
          "type": "u32",
          "value": "07000000",
          "docs": []
        },
        {
          "name": "TermDuration",
          "type": "T::BlockNumber",
          "value": "80130300",
          "docs": []
        },
        {
          "name": "ModuleId",
          "type": "LockIdentifier",
          "value": "706872656c656374",
          "docs": []
        }
      ],
      "index": 14
    },
    {
      "name": "FinalityTracker",
      "prefix": "Instance1Membership",
      "calls": [
        {
          "name": "final_hint",
          "args": [
            {
              "name": "hint",
              "type": "Compact<T::BlockNumber>"
            }
          ],
          "docs": [
            " Hint that the author of this block thinks the best finalized",
            " block is the given number."
          ],
          "look_up": "0f00"
        }
      ],
      "events": [
        {
          "name": "MemberAdded",
          "args": [],
          "docs": [
            " The given member was added; see the transaction for who."
          ],
          "look_up": "0f00"
        },
        {
          "name": "MemberRemoved",
          "args": [],
          "docs": [
            " The given member was removed; see the transaction for who."
          ],
          "look_up": "0f01"
        },
        {
          "name": "MembersSwapped",
          "args": [],
          "docs": [
            " Two members were swapped; see the transaction for who."
          ],
          "look_up": "0f02"
        },
        {
          "name": "MembersReset",
          "args": [],
          "docs": [
            " The membership was reset; see the transaction for who the new set is."
          ],
          "look_up": "0f03"
        },
        {
          "name": "KeyChanged",
          "args": [],
          "docs": [
            " One of the members' keys changed."
          ],
          "look_up": "0f04"
        },
        {
          "name": "Dummy",
          "args": [
            "sp_std::marker::PhantomData<(AccountId, Event)>"
          ],
          "docs": [
            " Phantom member, never used."
          ],
          "look_up": "0f05"
        }
      ],
      "errors": [
        {
          "name": "AlreadyUpdated",
          "docs": [
            " Final hint must be updated only once in the block"
          ]
        },
        {
          "name": "BadHint",
          "docs": [
            " Finalized height above block number"
          ]
        }
      ],
      "constants": [
        {
          "name": "WindowSize",
          "type": "T::BlockNumber",
          "value": "65000000",
          "docs": [
            " The number of recent samples to keep from this chain. Default is 101."
          ]
        },
        {
          "name": "ReportLatency",
          "type": "T::BlockNumber",
          "value": "e8030000",
          "docs": [
            " The delay after which point things become suspicious. Default is 1000."
          ]
        }
      ],
      "index": 15
    },
    {
      "name": "Grandpa",
      "prefix": "GrandpaFinality",
      "calls": [
        {
          "name": "report_equivocation",
          "args": [
            {
              "name": "equivocation_proof",
              "type": "EquivocationProof<T::Hash, T::BlockNumber>"
            },
            {
              "name": "key_owner_proof",
              "type": "T::KeyOwnerProof"
            }
          ],
          "docs": [
            " Report voter equivocation\/misbehavior. This method will verify the",
            " equivocation proof and validate the given key ownership proof",
            " against the extracted offender. If both are valid, the offence",
            " will be reported."
          ],
          "look_up": "1000"
        },
        {
          "name": "report_equivocation_unsigned",
          "args": [
            {
              "name": "equivocation_proof",
              "type": "EquivocationProof<T::Hash, T::BlockNumber>"
            },
            {
              "name": "key_owner_proof",
              "type": "T::KeyOwnerProof"
            }
          ],
          "docs": [
            " Report voter equivocation\/misbehavior. This method will verify the",
            " equivocation proof and validate the given key ownership proof",
            " against the extracted offender. If both are valid, the offence",
            " will be reported.",
            "",
            " This extrinsic must be called unsigned and it is expected that only",
            " block authors will call it (validated in `ValidateUnsigned`), as such",
            " if the block author is defined it will be defined as the equivocation",
            " reporter."
          ],
          "look_up": "1001"
        },
        {
          "name": "note_stalled",
          "args": [
            {
              "name": "delay",
              "type": "T::BlockNumber"
            },
            {
              "name": "best_finalized_block_number",
              "type": "T::BlockNumber"
            }
          ],
          "docs": [
            " Note that the current authority set of the GRANDPA finality gadget has",
            " stalled. This will trigger a forced authority set change at the beginning",
            " of the next session, to be enacted `delay` blocks after that. The delay",
            " should be high enough to safely assume that the block signalling the",
            " forced change will not be re-orged (e.g. 1000 blocks). The GRANDPA voters",
            " will start the new authority set using the given finalized block as base.",
            " Only callable by root."
          ],
          "look_up": "1002"
        }
      ],
      "events": [
        {
          "name": "NewAuthorities",
          "args": [
            "AuthorityList"
          ],
          "docs": [
            " New authority set has been applied. [authority_set]"
          ],
          "look_up": "1000"
        },
        {
          "name": "Paused",
          "args": [],
          "docs": [
            " Current authority set has been paused."
          ],
          "look_up": "1001"
        },
        {
          "name": "Resumed",
          "args": [],
          "docs": [
            " Current authority set has been resumed."
          ],
          "look_up": "1002"
        }
      ],
      "errors": [
        {
          "name": "PauseFailed",
          "docs": [
            " Attempt to signal GRANDPA pause when the authority set isn't live",
            " (either paused or already pending pause)."
          ]
        },
        {
          "name": "ResumeFailed",
          "docs": [
            " Attempt to signal GRANDPA resume when the authority set isn't paused",
            " (either live or already pending resume)."
          ]
        },
        {
          "name": "ChangePending",
          "docs": [
            " Attempt to signal GRANDPA change with one already pending."
          ]
        },
        {
          "name": "TooSoon",
          "docs": [
            " Cannot signal forced change so soon after last."
          ]
        },
        {
          "name": "InvalidKeyOwnershipProof",
          "docs": [
            " A key ownership proof provided as part of an equivocation report is invalid."
          ]
        },
        {
          "name": "InvalidEquivocationProof",
          "docs": [
            " An equivocation proof provided as part of an equivocation report is invalid."
          ]
        },
        {
          "name": "DuplicateOffenceReport",
          "docs": [
            " A given equivocation report is valid but already previously reported."
          ]
        }
      ],
      "constants": [
        {
          "name": "WindowSize",
          "type": "T::BlockNumber",
          "value": "65000000",
          "docs": [
            " The number of recent samples to keep from this chain. Default is 101."
          ]
        },
        {
          "name": "ReportLatency",
          "type": "T::BlockNumber",
          "value": "e8030000",
          "docs": [
            " The delay after which point things become suspicious. Default is 1000."
          ]
        }
      ],
      "index": 16
    },
    {
      "name": "Treasury",
      "prefix": "Treasury",
      "calls": [
        {
          "name": "propose_spend",
          "args": [
            {
              "name": "value",
              "type": "Compact<BalanceOf<T>>"
            },
            {
              "name": "beneficiary",
              "type": "<T::Lookup as StaticLookup>::Source"
            }
          ],
          "docs": [
            " Put forward a suggestion for spending. A deposit proportional to the value",
            " is reserved and slashed if the proposal is rejected. It is returned once the",
            " proposal is awarded.",
            "",
            " # <weight>",
            " - Complexity: O(1)",
            " - DbReads: `ProposalCount`, `origin account`",
            " - DbWrites: `ProposalCount`, `Proposals`, `origin account`",
            " # <\/weight>"
          ],
          "look_up": "1100"
        },
        {
          "name": "reject_proposal",
          "args": [
            {
              "name": "proposal_id",
              "type": "Compact<ProposalIndex>"
            }
          ],
          "docs": [
            " Reject a proposed spend. The original deposit will be slashed.",
            "",
            " May only be called from `T::RejectOrigin`.",
            "",
            " # <weight>",
            " - Complexity: O(1)",
            " - DbReads: `Proposals`, `rejected proposer account`",
            " - DbWrites: `Proposals`, `rejected proposer account`",
            " # <\/weight>"
          ],
          "look_up": "1101"
        },
        {
          "name": "approve_proposal",
          "args": [
            {
              "name": "proposal_id",
              "type": "Compact<ProposalIndex>"
            }
          ],
          "docs": [
            " Approve a proposal. At a later time, the proposal will be allocated to the beneficiary",
            " and the original deposit will be returned.",
            "",
            " May only be called from `T::ApproveOrigin`.",
            "",
            " # <weight>",
            " - Complexity: O(1).",
            " - DbReads: `Proposals`, `Approvals`",
            " - DbWrite: `Approvals`",
            " # <\/weight>"
          ],
          "look_up": "1102"
        },
        {
          "name": "report_awesome",
          "args": [
            {
              "name": "reason",
              "type": "Vec<u8>"
            },
            {
              "name": "who",
              "type": "T::AccountId"
            }
          ],
          "docs": [
            " Report something `reason` that deserves a tip and claim any eventual the finder's fee.",
            "",
            " The dispatch origin for this call must be _Signed_.",
            "",
            " Payment: `TipReportDepositBase` will be reserved from the origin account, as well as",
            " `TipReportDepositPerByte` for each byte in `reason`.",
            "",
            " - `reason`: The reason for, or the thing that deserves, the tip; generally this will be",
            "   a UTF-8-encoded URL.",
            " - `who`: The account which should be credited for the tip.",
            "",
            " Emits `NewTip` if successful.",
            "",
            " # <weight>",
            " - Complexity: `O(R)` where `R` length of `reason`.",
            "   - encoding and hashing of 'reason'",
            " - DbReads: `Reasons`, `Tips`, `who account data`",
            " - DbWrites: `Tips`, `who account data`",
            " # <\/weight>"
          ],
          "look_up": "1103"
        },
        {
          "name": "retract_tip",
          "args": [
            {
              "name": "hash",
              "type": "T::Hash"
            }
          ],
          "docs": [
            " Retract a prior tip-report from `report_awesome`, and cancel the process of tipping.",
            "",
            " If successful, the original deposit will be unreserved.",
            "",
            " The dispatch origin for this call must be _Signed_ and the tip identified by `hash`",
            " must have been reported by the signing account through `report_awesome` (and not",
            " through `tip_new`).",
            "",
            " - `hash`: The identity of the open tip for which a tip value is declared. This is formed",
            "   as the hash of the tuple of the original tip `reason` and the beneficiary account ID.",
            "",
            " Emits `TipRetracted` if successful.",
            "",
            " # <weight>",
            " - Complexity: `O(1)`",
            "   - Depends on the length of `T::Hash` which is fixed.",
            " - DbReads: `Tips`, `origin account`",
            " - DbWrites: `Reasons`, `Tips`, `origin account`",
            " # <\/weight>"
          ],
          "look_up": "1104"
        },
        {
          "name": "tip_new",
          "args": [
            {
              "name": "reason",
              "type": "Vec<u8>"
            },
            {
              "name": "who",
              "type": "T::AccountId"
            },
            {
              "name": "tip_value",
              "type": "BalanceOf<T>"
            }
          ],
          "docs": [
            " Give a tip for something new; no finder's fee will be taken.",
            "",
            " The dispatch origin for this call must be _Signed_ and the signing account must be a",
            " member of the `Tippers` set.",
            "",
            " - `reason`: The reason for, or the thing that deserves, the tip; generally this will be",
            "   a UTF-8-encoded URL.",
            " - `who`: The account which should be credited for the tip.",
            " - `tip_value`: The amount of tip that the sender would like to give. The median tip",
            "   value of active tippers will be given to the `who`.",
            "",
            " Emits `NewTip` if successful.",
            "",
            " # <weight>",
            " - Complexity: `O(R + T)` where `R` length of `reason`, `T` is the number of tippers.",
            "   - `O(T)`: decoding `Tipper` vec of length `T`",
            "     `T` is charged as upper bound given by `ContainsLengthBound`.",
            "     The actual cost depends on the implementation of `T::Tippers`.",
            "   - `O(R)`: hashing and encoding of reason of length `R`",
            " - DbReads: `Tippers`, `Reasons`",
            " - DbWrites: `Reasons`, `Tips`",
            " # <\/weight>"
          ],
          "look_up": "1105"
        },
        {
          "name": "tip",
          "args": [
            {
              "name": "hash",
              "type": "T::Hash"
            },
            {
              "name": "tip_value",
              "type": "BalanceOf<T>"
            }
          ],
          "docs": [
            " Declare a tip value for an already-open tip.",
            "",
            " The dispatch origin for this call must be _Signed_ and the signing account must be a",
            " member of the `Tippers` set.",
            "",
            " - `hash`: The identity of the open tip for which a tip value is declared. This is formed",
            "   as the hash of the tuple of the hash of the original tip `reason` and the beneficiary",
            "   account ID.",
            " - `tip_value`: The amount of tip that the sender would like to give. The median tip",
            "   value of active tippers will be given to the `who`.",
            "",
            " Emits `TipClosing` if the threshold of tippers has been reached and the countdown period",
            " has started.",
            "",
            " # <weight>",
            " - Complexity: `O(T)` where `T` is the number of tippers.",
            "   decoding `Tipper` vec of length `T`, insert tip and check closing,",
            "   `T` is charged as upper bound given by `ContainsLengthBound`.",
            "   The actual cost depends on the implementation of `T::Tippers`.",
            "",
            "   Actually weight could be lower as it depends on how many tips are in `OpenTip` but it",
            "   is weighted as if almost full i.e of length `T-1`.",
            " - DbReads: `Tippers`, `Tips`",
            " - DbWrites: `Tips`",
            " # <\/weight>"
          ],
          "look_up": "1106"
        },
        {
          "name": "close_tip",
          "args": [
            {
              "name": "hash",
              "type": "T::Hash"
            }
          ],
          "docs": [
            " Close and payout a tip.",
            "",
            " The dispatch origin for this call must be _Signed_.",
            "",
            " The tip identified by `hash` must have finished its countdown period.",
            "",
            " - `hash`: The identity of the open tip for which a tip value is declared. This is formed",
            "   as the hash of the tuple of the original tip `reason` and the beneficiary account ID.",
            "",
            " # <weight>",
            " - Complexity: `O(T)` where `T` is the number of tippers.",
            "   decoding `Tipper` vec of length `T`.",
            "   `T` is charged as upper bound given by `ContainsLengthBound`.",
            "   The actual cost depends on the implementation of `T::Tippers`.",
            " - DbReads: `Tips`, `Tippers`, `tip finder`",
            " - DbWrites: `Reasons`, `Tips`, `Tippers`, `tip finder`",
            " # <\/weight>"
          ],
          "look_up": "1107"
        }
      ],
      "events": [
        {
          "name": "Proposed",
          "args": [
            "ProposalIndex"
          ],
          "docs": [
            " New proposal. [proposal_index]"
          ],
          "look_up": "1100"
        },
        {
          "name": "Spending",
          "args": [
            "Balance"
          ],
          "docs": [
            " We have ended a spend period and will now allocate funds. [budget_remaining]"
          ],
          "look_up": "1101"
        },
        {
          "name": "Awarded",
          "args": [
            "ProposalIndex",
            "Balance",
            "AccountId"
          ],
          "docs": [
            " Some funds have been allocated. [proposal_index, award, beneficiary]"
          ],
          "look_up": "1102"
        },
        {
          "name": "Rejected",
          "args": [
            "ProposalIndex",
            "Balance"
          ],
          "docs": [
            " A proposal was rejected; funds were slashed. [proposal_index, slashed]"
          ],
          "look_up": "1103"
        },
        {
          "name": "Burnt",
          "args": [
            "Balance"
          ],
          "docs": [
            " Some of our funds have been burnt. [burn]"
          ],
          "look_up": "1104"
        },
        {
          "name": "Rollover",
          "args": [
            "Balance"
          ],
          "docs": [
            " Spending has finished; this is the amount that rolls over until next spend. [budget_remaining]"
          ],
          "look_up": "1105"
        },
        {
          "name": "Deposit",
          "args": [
            "Balance"
          ],
          "docs": [
            " Some funds have been deposited. [deposit]"
          ],
          "look_up": "1106"
        },
        {
          "name": "NewTip",
          "args": [
            "Hash"
          ],
          "docs": [
            " A new tip suggestion has been opened. [tip_hash]"
          ],
          "look_up": "1107"
        },
        {
          "name": "TipClosing",
          "args": [
            "Hash"
          ],
          "docs": [
            " A tip suggestion has reached threshold and is closing. [tip_hash]"
          ],
          "look_up": "1108"
        },
        {
          "name": "TipClosed",
          "args": [
            "Hash",
            "AccountId",
            "Balance"
          ],
          "docs": [
            " A tip suggestion has been closed. [tip_hash, who, payout]"
          ],
          "look_up": "1109"
        },
        {
          "name": "TipRetracted",
          "args": [
            "Hash"
          ],
          "docs": [
            " A tip suggestion has been retracted. [tip_hash]"
          ],
          "look_up": "110a"
        }
      ],
      "errors": [
        {
          "name": "InsufficientProposersBalance",
          "docs": [
            " Proposer's balance is too low."
          ]
        },
        {
          "name": "InvalidProposalIndex",
          "docs": [
            " No proposal at that index."
          ]
        },
        {
          "name": "ReasonTooBig",
          "docs": [
            " The reason given is just too big."
          ]
        },
        {
          "name": "AlreadyKnown",
          "docs": [
            " The tip was already found\/started."
          ]
        },
        {
          "name": "UnknownTip",
          "docs": [
            " The tip hash is unknown."
          ]
        },
        {
          "name": "NotFinder",
          "docs": [
            " The account attempting to retract the tip is not the finder of the tip."
          ]
        },
        {
          "name": "StillOpen",
          "docs": [
            " The tip cannot be claimed\/closed because there are not enough tippers yet."
          ]
        },
        {
          "name": "Premature",
          "docs": [
            " The tip cannot be claimed\/closed because it's still in the countdown period."
          ]
        }
      ],
      "constants": [
        {
          "name": "ProposalBond",
          "type": "Permill",
          "value": "50c30000",
          "docs": [
            " Fraction of a proposal's value that should be bonded in order to place the proposal.",
            " An accepted proposal gets these back. A rejected proposal does not."
          ]
        },
        {
          "name": "ProposalBondMinimum",
          "type": "BalanceOf<T>",
          "value": "00407a10f35a00000000000000000000",
          "docs": [
            " Minimum amount of funds that should be placed in a deposit for making a proposal."
          ]
        },
        {
          "name": "SpendPeriod",
          "type": "T::BlockNumber",
          "value": "80700000",
          "docs": [
            " Period between successive spends."
          ]
        },
        {
          "name": "Burn",
          "type": "Permill",
          "value": "20a10700",
          "docs": [
            " Percentage of spare funds (if any) that are burnt per spend period."
          ]
        },
        {
          "name": "TipCountdown",
          "type": "T::BlockNumber",
          "value": "80700000",
          "docs": [
            " The period for which a tip remains open after is has achieved threshold tippers."
          ]
        },
        {
          "name": "TipFindersFee",
          "type": "Percent",
          "value": "14",
          "docs": [
            " The amount of the final tip which goes to the original reporter of the tip."
          ]
        },
        {
          "name": "TipReportDepositBase",
          "type": "BalanceOf<T>",
          "value": "00407a10f35a00000000000000000000",
          "docs": [
            " The amount held on deposit for placing a tip report."
          ]
        },
        {
          "name": "TipReportDepositPerByte",
          "type": "BalanceOf<T>",
          "value": "0010a5d4e80000000000000000000000",
          "docs": [
            " The amount held on deposit per byte within the tip report reason."
          ]
        },
        {
          "name": "ModuleId",
          "type": "ModuleId",
          "value": "70792f7472737279",
          "docs": [
            " The treasury's module id, used for deriving its sovereign account ID."
          ]
        }
      ],
      "index": 17
    },
    {
      "name": "Contracts",
      "prefix": "Contracts",
      "calls": [
        {
          "name": "update_schedule",
          "args": [
            {
              "name": "schedule",
              "type": "Schedule"
            }
          ],
          "docs": [
            " Updates the schedule for metering contracts.",
            "",
            " The schedule must have a greater version than the stored schedule."
          ],
          "look_up": "1200"
        },
        {
          "name": "put_code",
          "args": [
            {
              "name": "code",
              "type": "Vec<u8>"
            }
          ],
          "docs": [
            " Stores the given binary Wasm code into the chain's storage and returns its `codehash`.",
            " You can instantiate contracts only with stored code."
          ],
          "look_up": "1201"
        },
        {
          "name": "call",
          "args": [
            {
              "name": "dest",
              "type": "<T::Lookup as StaticLookup>::Source"
            },
            {
              "name": "value",
              "type": "Compact<BalanceOf<T>>"
            },
            {
              "name": "gas_limit",
              "type": "Compact<Gas>"
            },
            {
              "name": "data",
              "type": "Vec<u8>"
            }
          ],
          "docs": [
            " Makes a call to an account, optionally transferring some balance.",
            "",
            " * If the account is a smart-contract account, the associated code will be",
            " executed and any value will be transferred.",
            " * If the account is a regular account, any value will be transferred.",
            " * If no account exists and the call value is not less than `existential_deposit`,",
            " a regular account will be created and any value will be transferred."
          ],
          "look_up": "1202"
        },
        {
          "name": "instantiate",
          "args": [
            {
              "name": "endowment",
              "type": "Compact<BalanceOf<T>>"
            },
            {
              "name": "gas_limit",
              "type": "Compact<Gas>"
            },
            {
              "name": "code_hash",
              "type": "CodeHash<T>"
            },
            {
              "name": "data",
              "type": "Vec<u8>"
            }
          ],
          "docs": [
            " Instantiates a new contract from the `codehash` generated by `put_code`, optionally transferring some balance.",
            "",
            " Instantiation is executed as follows:",
            "",
            " - The destination address is computed based on the sender and hash of the code.",
            " - The smart-contract account is created at the computed address.",
            " - The `ctor_code` is executed in the context of the newly-created account. Buffer returned",
            "   after the execution is saved as the `code` of the account. That code will be invoked",
            "   upon any call received by this account.",
            " - The contract is initialized."
          ],
          "look_up": "1203"
        },
        {
          "name": "claim_surcharge",
          "args": [
            {
              "name": "dest",
              "type": "T::AccountId"
            },
            {
              "name": "aux_sender",
              "type": "Option<T::AccountId>"
            }
          ],
          "docs": [
            " Allows block producers to claim a small reward for evicting a contract. If a block producer",
            " fails to do so, a regular users will be allowed to claim the reward.",
            "",
            " If contract is not evicted as a result of this call, no actions are taken and",
            " the sender is not eligible for the reward."
          ],
          "look_up": "1204"
        }
      ],
      "events": [
        {
          "name": "Instantiated",
          "args": [
            "AccountId",
            "AccountId"
          ],
          "docs": [
            " Contract deployed by address at the specified address. [owner, contract]"
          ],
          "look_up": "1200"
        },
        {
          "name": "Evicted",
          "args": [
            "AccountId",
            "bool"
          ],
          "docs": [
            " Contract has been evicted and is now in tombstone state.",
            " [contract, tombstone]",
            " ",
            " # Params",
            "",
            " - `contract`: `AccountId`: The account ID of the evicted contract.",
            " - `tombstone`: `bool`: True if the evicted contract left behind a tombstone."
          ],
          "look_up": "1201"
        },
        {
          "name": "Restored",
          "args": [
            "AccountId",
            "AccountId",
            "Hash",
            "Balance"
          ],
          "docs": [
            " Restoration for a contract has been successful.",
            " [donor, dest, code_hash, rent_allowance]",
            " ",
            " # Params",
            "",
            " - `donor`: `AccountId`: Account ID of the restoring contract",
            " - `dest`: `AccountId`: Account ID of the restored contract",
            " - `code_hash`: `Hash`: Code hash of the restored contract",
            " - `rent_allowance: `Balance`: Rent allowance of the restored contract"
          ],
          "look_up": "1202"
        },
        {
          "name": "CodeStored",
          "args": [
            "Hash"
          ],
          "docs": [
            " Code with the specified hash has been stored.",
            " [code_hash]"
          ],
          "look_up": "1203"
        },
        {
          "name": "ScheduleUpdated",
          "args": [
            "u32"
          ],
          "docs": [
            " Triggered when the current [schedule] is updated."
          ],
          "look_up": "1204"
        },
        {
          "name": "ContractExecution",
          "args": [
            "AccountId",
            "Vec<u8>"
          ],
          "docs": [
            " An event deposited upon execution of a contract from the account.",
            " [account, data]"
          ],
          "look_up": "1205"
        }
      ],
      "errors": [
        {
          "name": "InvalidScheduleVersion",
          "docs": [
            " A new schedule must have a greater version than the current one."
          ]
        },
        {
          "name": "InvalidSurchargeClaim",
          "docs": [
            " An origin must be signed or inherent and auxiliary sender only provided on inherent."
          ]
        },
        {
          "name": "InvalidSourceContract",
          "docs": [
            " Cannot restore from nonexisting or tombstone contract."
          ]
        },
        {
          "name": "InvalidDestinationContract",
          "docs": [
            " Cannot restore to nonexisting or alive contract."
          ]
        },
        {
          "name": "InvalidTombstone",
          "docs": [
            " Tombstones don't match."
          ]
        },
        {
          "name": "InvalidContractOrigin",
          "docs": [
            " An origin TrieId written in the current block."
          ]
        },
        {
          "name": "OutOfGas",
          "docs": [
            " The executed contract exhausted its gas limit."
          ]
        },
        {
          "name": "OutputBufferTooSmall",
          "docs": [
            " The output buffer supplied to a contract API call was too small."
          ]
        },
        {
          "name": "BelowSubsistenceThreshold",
          "docs": [
            " Performing the requested transfer would have brought the contract below",
            " the subsistence threshold. No transfer is allowed to do this in order to allow",
            " for a tombstone to be created. Use `seal_terminate` to remove a contract without",
            " leaving a tombstone behind."
          ]
        },
        {
          "name": "NewContractNotFunded",
          "docs": [
            " The newly created contract is below the subsistence threshold after executing",
            " its contructor. No contracts are allowed to exist below that threshold."
          ]
        },
        {
          "name": "TransferFailed",
          "docs": [
            " Performing the requested transfer failed for a reason originating in the",
            " chosen currency implementation of the runtime. Most probably the balance is",
            " too low or locks are placed on it."
          ]
        },
        {
          "name": "MaxCallDepthReached",
          "docs": [
            " Performing a call was denied because the calling depth reached the limit",
            " of what is specified in the schedule."
          ]
        },
        {
          "name": "NotCallable",
          "docs": [
            " The contract that was called is either no contract at all (a plain account)",
            " or is a tombstone."
          ]
        },
        {
          "name": "CodeTooLarge",
          "docs": [
            " The code supplied to `put_code` exceeds the limit specified in the current schedule."
          ]
        },
        {
          "name": "CodeNotFound",
          "docs": [
            " No code could be found at the supplied code hash."
          ]
        },
        {
          "name": "OutOfBounds",
          "docs": [
            " A buffer outside of sandbox memory was passed to a contract API function."
          ]
        },
        {
          "name": "DecodingFailed",
          "docs": [
            " Input passed to a contract API function failed to decode as expected type."
          ]
        },
        {
          "name": "ContractTrapped",
          "docs": [
            " Contract trapped during execution."
          ]
        }
      ],
      "constants": [
        {
          "name": "SignedClaimHandicap",
          "type": "T::BlockNumber",
          "value": "02000000",
          "docs": [
            " Number of block delay an extrinsic claim surcharge has.",
            "",
            " When claim surcharge is called by an extrinsic the rent is checked",
            " for current_block - delay"
          ]
        },
        {
          "name": "TombstoneDeposit",
          "type": "BalanceOf<T>",
          "value": "00a0acb9030000000000000000000000",
          "docs": [
            " The minimum amount required to generate a tombstone."
          ]
        },
        {
          "name": "StorageSizeOffset",
          "type": "u32",
          "value": "08000000",
          "docs": [
            " A size offset for an contract. A just created account with untouched storage will have that",
            " much of storage from the perspective of the state rent.",
            "",
            " This is a simple way to ensure that contracts with empty storage eventually get deleted",
            " by making them pay rent. This creates an incentive to remove them early in order to save",
            " rent."
          ]
        },
        {
          "name": "RentByteFee",
          "type": "BalanceOf<T>",
          "value": "00286bee000000000000000000000000",
          "docs": [
            " Price of a byte of storage per one block interval. Should be greater than 0."
          ]
        },
        {
          "name": "RentDepositOffset",
          "type": "BalanceOf<T>",
          "value": "0010a5d4e80000000000000000000000",
          "docs": [
            " The amount of funds a contract should deposit in order to offset",
            " the cost of one byte.",
            "",
            " Let's suppose the deposit is 1,000 BU (balance units)\/byte and the rent is 1 BU\/byte\/day,",
            " then a contract with 1,000,000 BU that uses 1,000 bytes of storage would pay no rent.",
            " But if the balance reduced to 500,000 BU and the storage stayed the same at 1,000,",
            " then it would pay 500 BU\/day."
          ]
        },
        {
          "name": "SurchargeReward",
          "type": "BalanceOf<T>",
          "value": "005cb2ec220000000000000000000000",
          "docs": [
            " Reward that is received by the party whose touch has led",
            " to removal of a contract."
          ]
        },
        {
          "name": "MaxDepth",
          "type": "u32",
          "value": "20000000",
          "docs": [
            " The maximum nesting level of a call\/instantiate stack. A reasonable default",
            " value is 100."
          ]
        },
        {
          "name": "MaxValueSize",
          "type": "u32",
          "value": "00400000",
          "docs": [
            " The maximum size of a storage value in bytes. A reasonable default is 16 KiB."
          ]
        }
      ],
      "index": 18
    },
    {
      "name": "Sudo",
      "prefix": "Sudo",
      "calls": [
        {
          "name": "sudo",
          "args": [
            {
              "name": "call",
              "type": "Box<<T as Trait>::Call>"
            }
          ],
          "docs": [
            " Authenticates the sudo key and dispatches a function call with `Root` origin.",
            "",
            " The dispatch origin for this call must be _Signed_.",
            "",
            " # <weight>",
            " - O(1).",
            " - Limited storage reads.",
            " - One DB write (event).",
            " - Weight of derivative `call` execution + 10,000.",
            " # <\/weight>"
          ],
          "look_up": "1300"
        },
        {
          "name": "sudo_unchecked_weight",
          "args": [
            {
              "name": "call",
              "type": "Box<<T as Trait>::Call>"
            },
            {
              "name": "_weight",
              "type": "Weight"
            }
          ],
          "docs": [
            " Authenticates the sudo key and dispatches a function call with `Root` origin.",
            " This function does not check the weight of the call, and instead allows the",
            " Sudo user to specify the weight of the call.",
            "",
            " The dispatch origin for this call must be _Signed_.",
            "",
            " # <weight>",
            " - O(1).",
            " - The weight of this call is defined by the caller.",
            " # <\/weight>"
          ],
          "look_up": "1301"
        },
        {
          "name": "set_key",
          "args": [
            {
              "name": "new",
              "type": "<T::Lookup as StaticLookup>::Source"
            }
          ],
          "docs": [
            " Authenticates the current sudo key and sets the given AccountId (`new`) as the new sudo key.",
            "",
            " The dispatch origin for this call must be _Signed_.",
            "",
            " # <weight>",
            " - O(1).",
            " - Limited storage reads.",
            " - One DB change.",
            " # <\/weight>"
          ],
          "look_up": "1302"
        },
        {
          "name": "sudo_as",
          "args": [
            {
              "name": "who",
              "type": "<T::Lookup as StaticLookup>::Source"
            },
            {
              "name": "call",
              "type": "Box<<T as Trait>::Call>"
            }
          ],
          "docs": [
            " Authenticates the sudo key and dispatches a function call with `Signed` origin from",
            " a given account.",
            "",
            " The dispatch origin for this call must be _Signed_.",
            "",
            " # <weight>",
            " - O(1).",
            " - Limited storage reads.",
            " - One DB write (event).",
            " - Weight of derivative `call` execution + 10,000.",
            " # <\/weight>"
          ],
          "look_up": "1303"
        }
      ],
      "events": [
        {
          "name": "Sudid",
          "args": [
            "DispatchResult"
          ],
          "docs": [
            " A sudo just took place. [result]"
          ],
          "look_up": "1300"
        },
        {
          "name": "KeyChanged",
          "args": [
            "AccountId"
          ],
          "docs": [
            " The [sudoer] just switched identity; the old key is supplied."
          ],
          "look_up": "1301"
        },
        {
          "name": "SudoAsDone",
          "args": [
            "bool"
          ],
          "docs": [
            " A sudo just took place. [result]"
          ],
          "look_up": "1302"
        }
      ],
      "errors": [
        {
          "name": "RequireSudo",
          "docs": [
            " Sender must be the Sudo account"
          ]
        }
      ],
      "constants": [
        {
          "name": "SignedClaimHandicap",
          "type": "T::BlockNumber",
          "value": "02000000",
          "docs": [
            " Number of block delay an extrinsic claim surcharge has.",
            "",
            " When claim surcharge is called by an extrinsic the rent is checked",
            " for current_block - delay"
          ]
        },
        {
          "name": "TombstoneDeposit",
          "type": "BalanceOf<T>",
          "value": "00a0acb9030000000000000000000000",
          "docs": [
            " The minimum amount required to generate a tombstone."
          ]
        },
        {
          "name": "StorageSizeOffset",
          "type": "u32",
          "value": "08000000",
          "docs": [
            " A size offset for an contract. A just created account with untouched storage will have that",
            " much of storage from the perspective of the state rent.",
            "",
            " This is a simple way to ensure that contracts with empty storage eventually get deleted",
            " by making them pay rent. This creates an incentive to remove them early in order to save",
            " rent."
          ]
        },
        {
          "name": "RentByteFee",
          "type": "BalanceOf<T>",
          "value": "00286bee000000000000000000000000",
          "docs": [
            " Price of a byte of storage per one block interval. Should be greater than 0."
          ]
        },
        {
          "name": "RentDepositOffset",
          "type": "BalanceOf<T>",
          "value": "0010a5d4e80000000000000000000000",
          "docs": [
            " The amount of funds a contract should deposit in order to offset",
            " the cost of one byte.",
            "",
            " Let's suppose the deposit is 1,000 BU (balance units)\/byte and the rent is 1 BU\/byte\/day,",
            " then a contract with 1,000,000 BU that uses 1,000 bytes of storage would pay no rent.",
            " But if the balance reduced to 500,000 BU and the storage stayed the same at 1,000,",
            " then it would pay 500 BU\/day."
          ]
        },
        {
          "name": "SurchargeReward",
          "type": "BalanceOf<T>",
          "value": "005cb2ec220000000000000000000000",
          "docs": [
            " Reward that is received by the party whose touch has led",
            " to removal of a contract."
          ]
        },
        {
          "name": "MaxDepth",
          "type": "u32",
          "value": "20000000",
          "docs": [
            " The maximum nesting level of a call\/instantiate stack. A reasonable default",
            " value is 100."
          ]
        },
        {
          "name": "MaxValueSize",
          "type": "u32",
          "value": "00400000",
          "docs": [
            " The maximum size of a storage value in bytes. A reasonable default is 16 KiB."
          ]
        }
      ],
      "index": 19
    },
    {
      "name": "ImOnline",
      "prefix": "ImOnline",
      "calls": [
        {
          "name": "heartbeat",
          "args": [
            {
              "name": "heartbeat",
              "type": "Heartbeat<T::BlockNumber>"
            },
            {
              "name": "_signature",
              "type": "<T::AuthorityId as RuntimeAppPublic>::Signature"
            }
          ],
          "docs": [
            " # <weight>",
            " - Complexity: `O(K + E)` where K is length of `Keys` and E is length of",
            "   `Heartbeat.network_state.external_address`",
            "",
            "   - `O(K)`: decoding of length `K`",
            "   - `O(E)`: decoding\/encoding of length `E`",
            " - DbReads: pallet_session `Validators`, pallet_session `CurrentIndex`, `Keys`,",
            "   `ReceivedHeartbeats`",
            " - DbWrites: `ReceivedHeartbeats`",
            " # <\/weight>"
          ],
          "look_up": "1400"
        }
      ],
      "events": [
        {
          "name": "HeartbeatReceived",
          "args": [
            "AuthorityId"
          ],
          "docs": [
            " A new heartbeat was received from `AuthorityId` [authority_id]"
          ],
          "look_up": "1400"
        },
        {
          "name": "AllGood",
          "args": [],
          "docs": [
            " At the end of the session, no offence was committed."
          ],
          "look_up": "1401"
        },
        {
          "name": "SomeOffline",
          "args": [
            "Vec<IdentificationTuple>"
          ],
          "docs": [
            " At the end of the session, at least one validator was found to be [offline]."
          ],
          "look_up": "1402"
        }
      ],
      "errors": [
        {
          "name": "InvalidKey",
          "docs": [
            " Non existent public key."
          ]
        },
        {
          "name": "DuplicatedHeartbeat",
          "docs": [
            " Duplicated heartbeat."
          ]
        }
      ],
      "constants": [
        {
          "name": "SignedClaimHandicap",
          "type": "T::BlockNumber",
          "value": "02000000",
          "docs": [
            " Number of block delay an extrinsic claim surcharge has.",
            "",
            " When claim surcharge is called by an extrinsic the rent is checked",
            " for current_block - delay"
          ]
        },
        {
          "name": "TombstoneDeposit",
          "type": "BalanceOf<T>",
          "value": "00a0acb9030000000000000000000000",
          "docs": [
            " The minimum amount required to generate a tombstone."
          ]
        },
        {
          "name": "StorageSizeOffset",
          "type": "u32",
          "value": "08000000",
          "docs": [
            " A size offset for an contract. A just created account with untouched storage will have that",
            " much of storage from the perspective of the state rent.",
            "",
            " This is a simple way to ensure that contracts with empty storage eventually get deleted",
            " by making them pay rent. This creates an incentive to remove them early in order to save",
            " rent."
          ]
        },
        {
          "name": "RentByteFee",
          "type": "BalanceOf<T>",
          "value": "00286bee000000000000000000000000",
          "docs": [
            " Price of a byte of storage per one block interval. Should be greater than 0."
          ]
        },
        {
          "name": "RentDepositOffset",
          "type": "BalanceOf<T>",
          "value": "0010a5d4e80000000000000000000000",
          "docs": [
            " The amount of funds a contract should deposit in order to offset",
            " the cost of one byte.",
            "",
            " Let's suppose the deposit is 1,000 BU (balance units)\/byte and the rent is 1 BU\/byte\/day,",
            " then a contract with 1,000,000 BU that uses 1,000 bytes of storage would pay no rent.",
            " But if the balance reduced to 500,000 BU and the storage stayed the same at 1,000,",
            " then it would pay 500 BU\/day."
          ]
        },
        {
          "name": "SurchargeReward",
          "type": "BalanceOf<T>",
          "value": "005cb2ec220000000000000000000000",
          "docs": [
            " Reward that is received by the party whose touch has led",
            " to removal of a contract."
          ]
        },
        {
          "name": "MaxDepth",
          "type": "u32",
          "value": "20000000",
          "docs": [
            " The maximum nesting level of a call\/instantiate stack. A reasonable default",
            " value is 100."
          ]
        },
        {
          "name": "MaxValueSize",
          "type": "u32",
          "value": "00400000",
          "docs": [
            " The maximum size of a storage value in bytes. A reasonable default is 16 KiB."
          ]
        }
      ],
      "index": 20
    },
    {
      "name": "AuthorityDiscovery",
      "prefix": "ImOnline",
      "calls": [
        {
          "name": "heartbeat",
          "args": [
            {
              "name": "heartbeat",
              "type": "Heartbeat<T::BlockNumber>"
            },
            {
              "name": "_signature",
              "type": "<T::AuthorityId as RuntimeAppPublic>::Signature"
            }
          ],
          "docs": [
            " # <weight>",
            " - Complexity: `O(K + E)` where K is length of `Keys` and E is length of",
            "   `Heartbeat.network_state.external_address`",
            "",
            "   - `O(K)`: decoding of length `K`",
            "   - `O(E)`: decoding\/encoding of length `E`",
            " - DbReads: pallet_session `Validators`, pallet_session `CurrentIndex`, `Keys`,",
            "   `ReceivedHeartbeats`",
            " - DbWrites: `ReceivedHeartbeats`",
            " # <\/weight>"
          ],
          "look_up": "1500"
        }
      ],
      "events": [
        {
          "name": "HeartbeatReceived",
          "args": [
            "AuthorityId"
          ],
          "docs": [
            " A new heartbeat was received from `AuthorityId` [authority_id]"
          ],
          "look_up": "1500"
        },
        {
          "name": "AllGood",
          "args": [],
          "docs": [
            " At the end of the session, no offence was committed."
          ],
          "look_up": "1501"
        },
        {
          "name": "SomeOffline",
          "args": [
            "Vec<IdentificationTuple>"
          ],
          "docs": [
            " At the end of the session, at least one validator was found to be [offline]."
          ],
          "look_up": "1502"
        }
      ],
      "errors": [
        {
          "name": "InvalidKey",
          "docs": [
            " Non existent public key."
          ]
        },
        {
          "name": "DuplicatedHeartbeat",
          "docs": [
            " Duplicated heartbeat."
          ]
        }
      ],
      "constants": [
        {
          "name": "SignedClaimHandicap",
          "type": "T::BlockNumber",
          "value": "02000000",
          "docs": [
            " Number of block delay an extrinsic claim surcharge has.",
            "",
            " When claim surcharge is called by an extrinsic the rent is checked",
            " for current_block - delay"
          ]
        },
        {
          "name": "TombstoneDeposit",
          "type": "BalanceOf<T>",
          "value": "00a0acb9030000000000000000000000",
          "docs": [
            " The minimum amount required to generate a tombstone."
          ]
        },
        {
          "name": "StorageSizeOffset",
          "type": "u32",
          "value": "08000000",
          "docs": [
            " A size offset for an contract. A just created account with untouched storage will have that",
            " much of storage from the perspective of the state rent.",
            "",
            " This is a simple way to ensure that contracts with empty storage eventually get deleted",
            " by making them pay rent. This creates an incentive to remove them early in order to save",
            " rent."
          ]
        },
        {
          "name": "RentByteFee",
          "type": "BalanceOf<T>",
          "value": "00286bee000000000000000000000000",
          "docs": [
            " Price of a byte of storage per one block interval. Should be greater than 0."
          ]
        },
        {
          "name": "RentDepositOffset",
          "type": "BalanceOf<T>",
          "value": "0010a5d4e80000000000000000000000",
          "docs": [
            " The amount of funds a contract should deposit in order to offset",
            " the cost of one byte.",
            "",
            " Let's suppose the deposit is 1,000 BU (balance units)\/byte and the rent is 1 BU\/byte\/day,",
            " then a contract with 1,000,000 BU that uses 1,000 bytes of storage would pay no rent.",
            " But if the balance reduced to 500,000 BU and the storage stayed the same at 1,000,",
            " then it would pay 500 BU\/day."
          ]
        },
        {
          "name": "SurchargeReward",
          "type": "BalanceOf<T>",
          "value": "005cb2ec220000000000000000000000",
          "docs": [
            " Reward that is received by the party whose touch has led",
            " to removal of a contract."
          ]
        },
        {
          "name": "MaxDepth",
          "type": "u32",
          "value": "20000000",
          "docs": [
            " The maximum nesting level of a call\/instantiate stack. A reasonable default",
            " value is 100."
          ]
        },
        {
          "name": "MaxValueSize",
          "type": "u32",
          "value": "00400000",
          "docs": [
            " The maximum size of a storage value in bytes. A reasonable default is 16 KiB."
          ]
        }
      ],
      "index": 21
    },
    {
      "name": "Offences",
      "prefix": "Offences",
      "calls": [
        {
          "name": "heartbeat",
          "args": [
            {
              "name": "heartbeat",
              "type": "Heartbeat<T::BlockNumber>"
            },
            {
              "name": "_signature",
              "type": "<T::AuthorityId as RuntimeAppPublic>::Signature"
            }
          ],
          "docs": [
            " # <weight>",
            " - Complexity: `O(K + E)` where K is length of `Keys` and E is length of",
            "   `Heartbeat.network_state.external_address`",
            "",
            "   - `O(K)`: decoding of length `K`",
            "   - `O(E)`: decoding\/encoding of length `E`",
            " - DbReads: pallet_session `Validators`, pallet_session `CurrentIndex`, `Keys`,",
            "   `ReceivedHeartbeats`",
            " - DbWrites: `ReceivedHeartbeats`",
            " # <\/weight>"
          ],
          "look_up": "1600"
        }
      ],
      "events": [
        {
          "name": "Offence",
          "args": [
            "Kind",
            "OpaqueTimeSlot",
            "bool"
          ],
          "docs": [
            " There is an offence reported of the given `kind` happened at the `session_index` and",
            " (kind-specific) time slot. This event is not deposited for duplicate slashes. last",
            " element indicates of the offence was applied (true) or queued (false) ",
            " [kind, timeslot, applied]."
          ],
          "look_up": "1600"
        }
      ],
      "errors": [
        {
          "name": "InvalidKey",
          "docs": [
            " Non existent public key."
          ]
        },
        {
          "name": "DuplicatedHeartbeat",
          "docs": [
            " Duplicated heartbeat."
          ]
        }
      ],
      "constants": [
        {
          "name": "SignedClaimHandicap",
          "type": "T::BlockNumber",
          "value": "02000000",
          "docs": [
            " Number of block delay an extrinsic claim surcharge has.",
            "",
            " When claim surcharge is called by an extrinsic the rent is checked",
            " for current_block - delay"
          ]
        },
        {
          "name": "TombstoneDeposit",
          "type": "BalanceOf<T>",
          "value": "00a0acb9030000000000000000000000",
          "docs": [
            " The minimum amount required to generate a tombstone."
          ]
        },
        {
          "name": "StorageSizeOffset",
          "type": "u32",
          "value": "08000000",
          "docs": [
            " A size offset for an contract. A just created account with untouched storage will have that",
            " much of storage from the perspective of the state rent.",
            "",
            " This is a simple way to ensure that contracts with empty storage eventually get deleted",
            " by making them pay rent. This creates an incentive to remove them early in order to save",
            " rent."
          ]
        },
        {
          "name": "RentByteFee",
          "type": "BalanceOf<T>",
          "value": "00286bee000000000000000000000000",
          "docs": [
            " Price of a byte of storage per one block interval. Should be greater than 0."
          ]
        },
        {
          "name": "RentDepositOffset",
          "type": "BalanceOf<T>",
          "value": "0010a5d4e80000000000000000000000",
          "docs": [
            " The amount of funds a contract should deposit in order to offset",
            " the cost of one byte.",
            "",
            " Let's suppose the deposit is 1,000 BU (balance units)\/byte and the rent is 1 BU\/byte\/day,",
            " then a contract with 1,000,000 BU that uses 1,000 bytes of storage would pay no rent.",
            " But if the balance reduced to 500,000 BU and the storage stayed the same at 1,000,",
            " then it would pay 500 BU\/day."
          ]
        },
        {
          "name": "SurchargeReward",
          "type": "BalanceOf<T>",
          "value": "005cb2ec220000000000000000000000",
          "docs": [
            " Reward that is received by the party whose touch has led",
            " to removal of a contract."
          ]
        },
        {
          "name": "MaxDepth",
          "type": "u32",
          "value": "20000000",
          "docs": [
            " The maximum nesting level of a call\/instantiate stack. A reasonable default",
            " value is 100."
          ]
        },
        {
          "name": "MaxValueSize",
          "type": "u32",
          "value": "00400000",
          "docs": [
            " The maximum size of a storage value in bytes. A reasonable default is 16 KiB."
          ]
        }
      ],
      "index": 22
    },
    {
      "name": "Historical",
      "prefix": "Offences",
      "calls": [
        {
          "name": "heartbeat",
          "args": [
            {
              "name": "heartbeat",
              "type": "Heartbeat<T::BlockNumber>"
            },
            {
              "name": "_signature",
              "type": "<T::AuthorityId as RuntimeAppPublic>::Signature"
            }
          ],
          "docs": [
            " # <weight>",
            " - Complexity: `O(K + E)` where K is length of `Keys` and E is length of",
            "   `Heartbeat.network_state.external_address`",
            "",
            "   - `O(K)`: decoding of length `K`",
            "   - `O(E)`: decoding\/encoding of length `E`",
            " - DbReads: pallet_session `Validators`, pallet_session `CurrentIndex`, `Keys`,",
            "   `ReceivedHeartbeats`",
            " - DbWrites: `ReceivedHeartbeats`",
            " # <\/weight>"
          ],
          "look_up": "1700"
        }
      ],
      "events": [
        {
          "name": "Offence",
          "args": [
            "Kind",
            "OpaqueTimeSlot",
            "bool"
          ],
          "docs": [
            " There is an offence reported of the given `kind` happened at the `session_index` and",
            " (kind-specific) time slot. This event is not deposited for duplicate slashes. last",
            " element indicates of the offence was applied (true) or queued (false) ",
            " [kind, timeslot, applied]."
          ],
          "look_up": "1700"
        }
      ],
      "errors": [
        {
          "name": "InvalidKey",
          "docs": [
            " Non existent public key."
          ]
        },
        {
          "name": "DuplicatedHeartbeat",
          "docs": [
            " Duplicated heartbeat."
          ]
        }
      ],
      "constants": [
        {
          "name": "SignedClaimHandicap",
          "type": "T::BlockNumber",
          "value": "02000000",
          "docs": [
            " Number of block delay an extrinsic claim surcharge has.",
            "",
            " When claim surcharge is called by an extrinsic the rent is checked",
            " for current_block - delay"
          ]
        },
        {
          "name": "TombstoneDeposit",
          "type": "BalanceOf<T>",
          "value": "00a0acb9030000000000000000000000",
          "docs": [
            " The minimum amount required to generate a tombstone."
          ]
        },
        {
          "name": "StorageSizeOffset",
          "type": "u32",
          "value": "08000000",
          "docs": [
            " A size offset for an contract. A just created account with untouched storage will have that",
            " much of storage from the perspective of the state rent.",
            "",
            " This is a simple way to ensure that contracts with empty storage eventually get deleted",
            " by making them pay rent. This creates an incentive to remove them early in order to save",
            " rent."
          ]
        },
        {
          "name": "RentByteFee",
          "type": "BalanceOf<T>",
          "value": "00286bee000000000000000000000000",
          "docs": [
            " Price of a byte of storage per one block interval. Should be greater than 0."
          ]
        },
        {
          "name": "RentDepositOffset",
          "type": "BalanceOf<T>",
          "value": "0010a5d4e80000000000000000000000",
          "docs": [
            " The amount of funds a contract should deposit in order to offset",
            " the cost of one byte.",
            "",
            " Let's suppose the deposit is 1,000 BU (balance units)\/byte and the rent is 1 BU\/byte\/day,",
            " then a contract with 1,000,000 BU that uses 1,000 bytes of storage would pay no rent.",
            " But if the balance reduced to 500,000 BU and the storage stayed the same at 1,000,",
            " then it would pay 500 BU\/day."
          ]
        },
        {
          "name": "SurchargeReward",
          "type": "BalanceOf<T>",
          "value": "005cb2ec220000000000000000000000",
          "docs": [
            " Reward that is received by the party whose touch has led",
            " to removal of a contract."
          ]
        },
        {
          "name": "MaxDepth",
          "type": "u32",
          "value": "20000000",
          "docs": [
            " The maximum nesting level of a call\/instantiate stack. A reasonable default",
            " value is 100."
          ]
        },
        {
          "name": "MaxValueSize",
          "type": "u32",
          "value": "00400000",
          "docs": [
            " The maximum size of a storage value in bytes. A reasonable default is 16 KiB."
          ]
        }
      ],
      "index": 23
    },
    {
      "name": "RandomnessCollectiveFlip",
      "prefix": "RandomnessCollectiveFlip",
      "calls": [
        {
          "name": "heartbeat",
          "args": [
            {
              "name": "heartbeat",
              "type": "Heartbeat<T::BlockNumber>"
            },
            {
              "name": "_signature",
              "type": "<T::AuthorityId as RuntimeAppPublic>::Signature"
            }
          ],
          "docs": [
            " # <weight>",
            " - Complexity: `O(K + E)` where K is length of `Keys` and E is length of",
            "   `Heartbeat.network_state.external_address`",
            "",
            "   - `O(K)`: decoding of length `K`",
            "   - `O(E)`: decoding\/encoding of length `E`",
            " - DbReads: pallet_session `Validators`, pallet_session `CurrentIndex`, `Keys`,",
            "   `ReceivedHeartbeats`",
            " - DbWrites: `ReceivedHeartbeats`",
            " # <\/weight>"
          ],
          "look_up": "1800"
        }
      ],
      "events": [
        {
          "name": "Offence",
          "args": [
            "Kind",
            "OpaqueTimeSlot",
            "bool"
          ],
          "docs": [
            " There is an offence reported of the given `kind` happened at the `session_index` and",
            " (kind-specific) time slot. This event is not deposited for duplicate slashes. last",
            " element indicates of the offence was applied (true) or queued (false) ",
            " [kind, timeslot, applied]."
          ],
          "look_up": "1800"
        }
      ],
      "errors": [
        {
          "name": "InvalidKey",
          "docs": [
            " Non existent public key."
          ]
        },
        {
          "name": "DuplicatedHeartbeat",
          "docs": [
            " Duplicated heartbeat."
          ]
        }
      ],
      "constants": [
        {
          "name": "SignedClaimHandicap",
          "type": "T::BlockNumber",
          "value": "02000000",
          "docs": [
            " Number of block delay an extrinsic claim surcharge has.",
            "",
            " When claim surcharge is called by an extrinsic the rent is checked",
            " for current_block - delay"
          ]
        },
        {
          "name": "TombstoneDeposit",
          "type": "BalanceOf<T>",
          "value": "00a0acb9030000000000000000000000",
          "docs": [
            " The minimum amount required to generate a tombstone."
          ]
        },
        {
          "name": "StorageSizeOffset",
          "type": "u32",
          "value": "08000000",
          "docs": [
            " A size offset for an contract. A just created account with untouched storage will have that",
            " much of storage from the perspective of the state rent.",
            "",
            " This is a simple way to ensure that contracts with empty storage eventually get deleted",
            " by making them pay rent. This creates an incentive to remove them early in order to save",
            " rent."
          ]
        },
        {
          "name": "RentByteFee",
          "type": "BalanceOf<T>",
          "value": "00286bee000000000000000000000000",
          "docs": [
            " Price of a byte of storage per one block interval. Should be greater than 0."
          ]
        },
        {
          "name": "RentDepositOffset",
          "type": "BalanceOf<T>",
          "value": "0010a5d4e80000000000000000000000",
          "docs": [
            " The amount of funds a contract should deposit in order to offset",
            " the cost of one byte.",
            "",
            " Let's suppose the deposit is 1,000 BU (balance units)\/byte and the rent is 1 BU\/byte\/day,",
            " then a contract with 1,000,000 BU that uses 1,000 bytes of storage would pay no rent.",
            " But if the balance reduced to 500,000 BU and the storage stayed the same at 1,000,",
            " then it would pay 500 BU\/day."
          ]
        },
        {
          "name": "SurchargeReward",
          "type": "BalanceOf<T>",
          "value": "005cb2ec220000000000000000000000",
          "docs": [
            " Reward that is received by the party whose touch has led",
            " to removal of a contract."
          ]
        },
        {
          "name": "MaxDepth",
          "type": "u32",
          "value": "20000000",
          "docs": [
            " The maximum nesting level of a call\/instantiate stack. A reasonable default",
            " value is 100."
          ]
        },
        {
          "name": "MaxValueSize",
          "type": "u32",
          "value": "00400000",
          "docs": [
            " The maximum size of a storage value in bytes. A reasonable default is 16 KiB."
          ]
        }
      ],
      "index": 24
    },
    {
      "name": "Identity",
      "prefix": "Identity",
      "calls": [
        {
          "name": "add_registrar",
          "args": [
            {
              "name": "account",
              "type": "T::AccountId"
            }
          ],
          "docs": [
            " Add a registrar to the system.",
            "",
            " The dispatch origin for this call must be `T::RegistrarOrigin`.",
            "",
            " - `account`: the account of the registrar.",
            "",
            " Emits `RegistrarAdded` if successful.",
            "",
            " # <weight>",
            " - `O(R)` where `R` registrar-count (governance-bounded and code-bounded).",
            " - One storage mutation (codec `O(R)`).",
            " - One event.",
            " # <\/weight>"
          ],
          "look_up": "1900"
        },
        {
          "name": "set_identity",
          "args": [
            {
              "name": "info",
              "type": "IdentityInfo"
            }
          ],
          "docs": [
            " Set an account's identity information and reserve the appropriate deposit.",
            "",
            " If the account already has identity information, the deposit is taken as part payment",
            " for the new deposit.",
            "",
            " The dispatch origin for this call must be _Signed_.",
            "",
            " - `info`: The identity information.",
            "",
            " Emits `IdentitySet` if successful.",
            "",
            " # <weight>",
            " - `O(X + X' + R)`",
            "   - where `X` additional-field-count (deposit-bounded and code-bounded)",
            "   - where `R` judgements-count (registrar-count-bounded)",
            " - One balance reserve operation.",
            " - One storage mutation (codec-read `O(X' + R)`, codec-write `O(X + R)`).",
            " - One event.",
            " # <\/weight>"
          ],
          "look_up": "1901"
        },
        {
          "name": "set_subs",
          "args": [
            {
              "name": "subs",
              "type": "Vec<(T::AccountId, Data)>"
            }
          ],
          "docs": [
            " Set the sub-accounts of the sender.",
            "",
            " Payment: Any aggregate balance reserved by previous `set_subs` calls will be returned",
            " and an amount `SubAccountDeposit` will be reserved for each item in `subs`.",
            "",
            " The dispatch origin for this call must be _Signed_ and the sender must have a registered",
            " identity.",
            "",
            " - `subs`: The identity's (new) sub-accounts.",
            "",
            " # <weight>",
            " - `O(P + S)`",
            "   - where `P` old-subs-count (hard- and deposit-bounded).",
            "   - where `S` subs-count (hard- and deposit-bounded).",
            " - At most one balance operations.",
            " - DB:",
            "   - `P + S` storage mutations (codec complexity `O(1)`)",
            "   - One storage read (codec complexity `O(P)`).",
            "   - One storage write (codec complexity `O(S)`).",
            "   - One storage-exists (`IdentityOf::contains_key`).",
            " # <\/weight>"
          ],
          "look_up": "1902"
        },
        {
          "name": "clear_identity",
          "args": [],
          "docs": [
            " Clear an account's identity info and all sub-accounts and return all deposits.",
            "",
            " Payment: All reserved balances on the account are returned.",
            "",
            " The dispatch origin for this call must be _Signed_ and the sender must have a registered",
            " identity.",
            "",
            " Emits `IdentityCleared` if successful.",
            "",
            " # <weight>",
            " - `O(R + S + X)`",
            "   - where `R` registrar-count (governance-bounded).",
            "   - where `S` subs-count (hard- and deposit-bounded).",
            "   - where `X` additional-field-count (deposit-bounded and code-bounded).",
            " - One balance-unreserve operation.",
            " - `2` storage reads and `S + 2` storage deletions.",
            " - One event.",
            " # <\/weight>"
          ],
          "look_up": "1903"
        },
        {
          "name": "request_judgement",
          "args": [
            {
              "name": "reg_index",
              "type": "Compact<RegistrarIndex>"
            },
            {
              "name": "max_fee",
              "type": "Compact<BalanceOf<T>>"
            }
          ],
          "docs": [
            " Request a judgement from a registrar.",
            "",
            " Payment: At most `max_fee` will be reserved for payment to the registrar if judgement",
            " given.",
            "",
            " The dispatch origin for this call must be _Signed_ and the sender must have a",
            " registered identity.",
            "",
            " - `reg_index`: The index of the registrar whose judgement is requested.",
            " - `max_fee`: The maximum fee that may be paid. This should just be auto-populated as:",
            "",
            " ```nocompile",
            " Self::registrars().get(reg_index).unwrap().fee",
            " ```",
            "",
            " Emits `JudgementRequested` if successful.",
            "",
            " # <weight>",
            " - `O(R + X)`.",
            " - One balance-reserve operation.",
            " - Storage: 1 read `O(R)`, 1 mutate `O(X + R)`.",
            " - One event.",
            " # <\/weight>"
          ],
          "look_up": "1904"
        },
        {
          "name": "cancel_request",
          "args": [
            {
              "name": "reg_index",
              "type": "RegistrarIndex"
            }
          ],
          "docs": [
            " Cancel a previous request.",
            "",
            " Payment: A previously reserved deposit is returned on success.",
            "",
            " The dispatch origin for this call must be _Signed_ and the sender must have a",
            " registered identity.",
            "",
            " - `reg_index`: The index of the registrar whose judgement is no longer requested.",
            "",
            " Emits `JudgementUnrequested` if successful.",
            "",
            " # <weight>",
            " - `O(R + X)`.",
            " - One balance-reserve operation.",
            " - One storage mutation `O(R + X)`.",
            " - One event",
            " # <\/weight>"
          ],
          "look_up": "1905"
        },
        {
          "name": "set_fee",
          "args": [
            {
              "name": "index",
              "type": "Compact<RegistrarIndex>"
            },
            {
              "name": "fee",
              "type": "Compact<BalanceOf<T>>"
            }
          ],
          "docs": [
            " Set the fee required for a judgement to be requested from a registrar.",
            "",
            " The dispatch origin for this call must be _Signed_ and the sender must be the account",
            " of the registrar whose index is `index`.",
            "",
            " - `index`: the index of the registrar whose fee is to be set.",
            " - `fee`: the new fee.",
            "",
            " # <weight>",
            " - `O(R)`.",
            " - One storage mutation `O(R)`.",
            " - Benchmark: 7.315 + R * 0.329 \u00b5s (min squares analysis)",
            " # <\/weight>"
          ],
          "look_up": "1906"
        },
        {
          "name": "set_account_id",
          "args": [
            {
              "name": "index",
              "type": "Compact<RegistrarIndex>"
            },
            {
              "name": "new",
              "type": "T::AccountId"
            }
          ],
          "docs": [
            " Change the account associated with a registrar.",
            "",
            " The dispatch origin for this call must be _Signed_ and the sender must be the account",
            " of the registrar whose index is `index`.",
            "",
            " - `index`: the index of the registrar whose fee is to be set.",
            " - `new`: the new account ID.",
            "",
            " # <weight>",
            " - `O(R)`.",
            " - One storage mutation `O(R)`.",
            " - Benchmark: 8.823 + R * 0.32 \u00b5s (min squares analysis)",
            " # <\/weight>"
          ],
          "look_up": "1907"
        },
        {
          "name": "set_fields",
          "args": [
            {
              "name": "index",
              "type": "Compact<RegistrarIndex>"
            },
            {
              "name": "fields",
              "type": "IdentityFields"
            }
          ],
          "docs": [
            " Set the field information for a registrar.",
            "",
            " The dispatch origin for this call must be _Signed_ and the sender must be the account",
            " of the registrar whose index is `index`.",
            "",
            " - `index`: the index of the registrar whose fee is to be set.",
            " - `fields`: the fields that the registrar concerns themselves with.",
            "",
            " # <weight>",
            " - `O(R)`.",
            " - One storage mutation `O(R)`.",
            " - Benchmark: 7.464 + R * 0.325 \u00b5s (min squares analysis)",
            " # <\/weight>"
          ],
          "look_up": "1908"
        },
        {
          "name": "provide_judgement",
          "args": [
            {
              "name": "reg_index",
              "type": "Compact<RegistrarIndex>"
            },
            {
              "name": "target",
              "type": "<T::Lookup as StaticLookup>::Source"
            },
            {
              "name": "judgement",
              "type": "Judgement<BalanceOf<T>>"
            }
          ],
          "docs": [
            " Provide a judgement for an account's identity.",
            "",
            " The dispatch origin for this call must be _Signed_ and the sender must be the account",
            " of the registrar whose index is `reg_index`.",
            "",
            " - `reg_index`: the index of the registrar whose judgement is being made.",
            " - `target`: the account whose identity the judgement is upon. This must be an account",
            "   with a registered identity.",
            " - `judgement`: the judgement of the registrar of index `reg_index` about `target`.",
            "",
            " Emits `JudgementGiven` if successful.",
            "",
            " # <weight>",
            " - `O(R + X)`.",
            " - One balance-transfer operation.",
            " - Up to one account-lookup operation.",
            " - Storage: 1 read `O(R)`, 1 mutate `O(R + X)`.",
            " - One event.",
            " # <\/weight>"
          ],
          "look_up": "1909"
        },
        {
          "name": "kill_identity",
          "args": [
            {
              "name": "target",
              "type": "<T::Lookup as StaticLookup>::Source"
            }
          ],
          "docs": [
            " Remove an account's identity and sub-account information and slash the deposits.",
            "",
            " Payment: Reserved balances from `set_subs` and `set_identity` are slashed and handled by",
            " `Slash`. Verification request deposits are not returned; they should be cancelled",
            " manually using `cancel_request`.",
            "",
            " The dispatch origin for this call must match `T::ForceOrigin`.",
            "",
            " - `target`: the account whose identity the judgement is upon. This must be an account",
            "   with a registered identity.",
            "",
            " Emits `IdentityKilled` if successful.",
            "",
            " # <weight>",
            " - `O(R + S + X)`.",
            " - One balance-reserve operation.",
            " - `S + 2` storage mutations.",
            " - One event.",
            " # <\/weight>"
          ],
          "look_up": "190a"
        },
        {
          "name": "add_sub",
          "args": [
            {
              "name": "sub",
              "type": "<T::Lookup as StaticLookup>::Source"
            },
            {
              "name": "data",
              "type": "Data"
            }
          ],
          "docs": [
            " Add the given account to the sender's subs.",
            "",
            " Payment: Balance reserved by a previous `set_subs` call for one sub will be repatriated",
            " to the sender.",
            "",
            " The dispatch origin for this call must be _Signed_ and the sender must have a registered",
            " sub identity of `sub`."
          ],
          "look_up": "190b"
        },
        {
          "name": "rename_sub",
          "args": [
            {
              "name": "sub",
              "type": "<T::Lookup as StaticLookup>::Source"
            },
            {
              "name": "data",
              "type": "Data"
            }
          ],
          "docs": [
            " Alter the associated name of the given sub-account.",
            "",
            " The dispatch origin for this call must be _Signed_ and the sender must have a registered",
            " sub identity of `sub`."
          ],
          "look_up": "190c"
        },
        {
          "name": "remove_sub",
          "args": [
            {
              "name": "sub",
              "type": "<T::Lookup as StaticLookup>::Source"
            }
          ],
          "docs": [
            " Remove the given account from the sender's subs.",
            "",
            " Payment: Balance reserved by a previous `set_subs` call for one sub will be repatriated",
            " to the sender.",
            "",
            " The dispatch origin for this call must be _Signed_ and the sender must have a registered",
            " sub identity of `sub`."
          ],
          "look_up": "190d"
        },
        {
          "name": "quit_sub",
          "args": [],
          "docs": [
            " Remove the sender as a sub-account.",
            "",
            " Payment: Balance reserved by a previous `set_subs` call for one sub will be repatriated",
            " to the sender (*not* the original depositor).",
            "",
            " The dispatch origin for this call must be _Signed_ and the sender must have a registered",
            " super-identity.",
            "",
            " NOTE: This should not normally be used, but is provided in the case that the non-",
            " controller of an account is maliciously registered as a sub-account."
          ],
          "look_up": "190e"
        }
      ],
      "events": [
        {
          "name": "IdentitySet",
          "args": [
            "AccountId"
          ],
          "docs": [
            " A name was set or reset (which will remove all judgements). [who]"
          ],
          "look_up": "1900"
        },
        {
          "name": "IdentityCleared",
          "args": [
            "AccountId",
            "Balance"
          ],
          "docs": [
            " A name was cleared, and the given balance returned. [who, deposit]"
          ],
          "look_up": "1901"
        },
        {
          "name": "IdentityKilled",
          "args": [
            "AccountId",
            "Balance"
          ],
          "docs": [
            " A name was removed and the given balance slashed. [who, deposit]"
          ],
          "look_up": "1902"
        },
        {
          "name": "JudgementRequested",
          "args": [
            "AccountId",
            "RegistrarIndex"
          ],
          "docs": [
            " A judgement was asked from a registrar. [who, registrar_index]"
          ],
          "look_up": "1903"
        },
        {
          "name": "JudgementUnrequested",
          "args": [
            "AccountId",
            "RegistrarIndex"
          ],
          "docs": [
            " A judgement request was retracted. [who, registrar_index]"
          ],
          "look_up": "1904"
        },
        {
          "name": "JudgementGiven",
          "args": [
            "AccountId",
            "RegistrarIndex"
          ],
          "docs": [
            " A judgement was given by a registrar. [target, registrar_index]"
          ],
          "look_up": "1905"
        },
        {
          "name": "RegistrarAdded",
          "args": [
            "RegistrarIndex"
          ],
          "docs": [
            " A registrar was added. [registrar_index]"
          ],
          "look_up": "1906"
        },
        {
          "name": "SubIdentityAdded",
          "args": [
            "AccountId",
            "AccountId",
            "Balance"
          ],
          "docs": [
            " A sub-identity was added to an identity and the deposit paid. [sub, main, deposit]"
          ],
          "look_up": "1907"
        },
        {
          "name": "SubIdentityRemoved",
          "args": [
            "AccountId",
            "AccountId",
            "Balance"
          ],
          "docs": [
            " A sub-identity was removed from an identity and the deposit freed.",
            " [sub, main, deposit]"
          ],
          "look_up": "1908"
        },
        {
          "name": "SubIdentityRevoked",
          "args": [
            "AccountId",
            "AccountId",
            "Balance"
          ],
          "docs": [
            " A sub-identity was cleared, and the given deposit repatriated from the",
            " main identity account to the sub-identity account. [sub, main, deposit]"
          ],
          "look_up": "1909"
        }
      ],
      "errors": [
        {
          "name": "TooManySubAccounts",
          "docs": [
            " Too many subs-accounts."
          ]
        },
        {
          "name": "NotFound",
          "docs": [
            " Account isn't found."
          ]
        },
        {
          "name": "NotNamed",
          "docs": [
            " Account isn't named."
          ]
        },
        {
          "name": "EmptyIndex",
          "docs": [
            " Empty index."
          ]
        },
        {
          "name": "FeeChanged",
          "docs": [
            " Fee is changed."
          ]
        },
        {
          "name": "NoIdentity",
          "docs": [
            " No identity found."
          ]
        },
        {
          "name": "StickyJudgement",
          "docs": [
            " Sticky judgement."
          ]
        },
        {
          "name": "JudgementGiven",
          "docs": [
            " Judgement given."
          ]
        },
        {
          "name": "InvalidJudgement",
          "docs": [
            " Invalid judgement."
          ]
        },
        {
          "name": "InvalidIndex",
          "docs": [
            " The index is invalid."
          ]
        },
        {
          "name": "InvalidTarget",
          "docs": [
            " The target is invalid."
          ]
        },
        {
          "name": "TooManyFields",
          "docs": [
            " Too many additional fields."
          ]
        },
        {
          "name": "TooManyRegistrars",
          "docs": [
            " Maximum amount of registrars reached. Cannot add any more."
          ]
        },
        {
          "name": "AlreadyClaimed",
          "docs": [
            " Account ID is already named."
          ]
        },
        {
          "name": "NotSub",
          "docs": [
            " Sender is not a sub-account."
          ]
        },
        {
          "name": "NotOwned",
          "docs": [
            " Sub-account isn't owned by sender."
          ]
        }
      ],
      "constants": [
        {
          "name": "BasicDeposit",
          "type": "BalanceOf<T>",
          "value": "0080c6a47e8d03000000000000000000",
          "docs": [
            " The amount held on deposit for a registered identity."
          ]
        },
        {
          "name": "FieldDeposit",
          "type": "BalanceOf<T>",
          "value": "00a031a95fe300000000000000000000",
          "docs": [
            " The amount held on deposit per additional field for a registered identity."
          ]
        },
        {
          "name": "SubAccountDeposit",
          "type": "BalanceOf<T>",
          "value": "0080f420e6b500000000000000000000",
          "docs": [
            " The amount held on deposit for a registered subaccount. This should account for the fact",
            " that one storage item's value will increase by the size of an account ID, and there will be",
            " another trie item whose value is the size of an account ID plus 32 bytes."
          ]
        },
        {
          "name": "MaxSubAccounts",
          "type": "u32",
          "value": "64000000",
          "docs": [
            " The maximum number of sub-accounts allowed per identified account."
          ]
        },
        {
          "name": "MaxAdditionalFields",
          "type": "u32",
          "value": "64000000",
          "docs": [
            " Maximum number of additional fields that may be stored in an ID. Needed to bound the I\/O",
            " required to access an identity, but can be pretty high."
          ]
        },
        {
          "name": "MaxRegistrars",
          "type": "u32",
          "value": "14000000",
          "docs": [
            " Maxmimum number of registrars allowed in the system. Needed to bound the complexity",
            " of, e.g., updating judgements."
          ]
        }
      ],
      "index": 25
    },
    {
      "name": "Society",
      "prefix": "Society",
      "calls": [
        {
          "name": "bid",
          "args": [
            {
              "name": "value",
              "type": "BalanceOf<T, I>"
            }
          ],
          "docs": [
            " A user outside of the society can make a bid for entry.",
            "",
            " Payment: `CandidateDeposit` will be reserved for making a bid. It is returned",
            " when the bid becomes a member, or if the bid calls `unbid`.",
            "",
            " The dispatch origin for this call must be _Signed_.",
            "",
            " Parameters:",
            " - `value`: A one time payment the bid would like to receive when joining the society.",
            "",
            " # <weight>",
            " Key: B (len of bids), C (len of candidates), M (len of members), X (balance reserve)",
            " - Storage Reads:",
            " \t- One storage read to check for suspended candidate. O(1)",
            " \t- One storage read to check for suspended member. O(1)",
            " \t- One storage read to retrieve all current bids. O(B)",
            " \t- One storage read to retrieve all current candidates. O(C)",
            " \t- One storage read to retrieve all members. O(M)",
            " - Storage Writes:",
            " \t- One storage mutate to add a new bid to the vector O(B) (TODO: possible optimization w\/ read)",
            " \t- Up to one storage removal if bid.len() > MAX_BID_COUNT. O(1)",
            " - Notable Computation:",
            " \t- O(B + C + log M) search to check user is not already a part of society.",
            " \t- O(log B) search to insert the new bid sorted.",
            " - External Module Operations:",
            " \t- One balance reserve operation. O(X)",
            " \t- Up to one balance unreserve operation if bids.len() > MAX_BID_COUNT.",
            " - Events:",
            " \t- One event for new bid.",
            " \t- Up to one event for AutoUnbid if bid.len() > MAX_BID_COUNT.",
            "",
            " Total Complexity: O(M + B + C + logM + logB + X)",
            " # <\/weight>"
          ],
          "look_up": "1a00"
        },
        {
          "name": "unbid",
          "args": [
            {
              "name": "pos",
              "type": "u32"
            }
          ],
          "docs": [
            " A bidder can remove their bid for entry into society.",
            " By doing so, they will have their candidate deposit returned or",
            " they will unvouch their voucher.",
            "",
            " Payment: The bid deposit is unreserved if the user made a bid.",
            "",
            " The dispatch origin for this call must be _Signed_ and a bidder.",
            "",
            " Parameters:",
            " - `pos`: Position in the `Bids` vector of the bid who wants to unbid.",
            "",
            " # <weight>",
            " Key: B (len of bids), X (balance unreserve)",
            " - One storage read and write to retrieve and update the bids. O(B)",
            " - Either one unreserve balance action O(X) or one vouching storage removal. O(1)",
            " - One event.",
            "",
            " Total Complexity: O(B + X)",
            " # <\/weight>"
          ],
          "look_up": "1a01"
        },
        {
          "name": "vouch",
          "args": [
            {
              "name": "who",
              "type": "T::AccountId"
            },
            {
              "name": "value",
              "type": "BalanceOf<T, I>"
            },
            {
              "name": "tip",
              "type": "BalanceOf<T, I>"
            }
          ],
          "docs": [
            " As a member, vouch for someone to join society by placing a bid on their behalf.",
            "",
            " There is no deposit required to vouch for a new bid, but a member can only vouch for",
            " one bid at a time. If the bid becomes a suspended candidate and ultimately rejected by",
            " the suspension judgement origin, the member will be banned from vouching again.",
            "",
            " As a vouching member, you can claim a tip if the candidate is accepted. This tip will",
            " be paid as a portion of the reward the member will receive for joining the society.",
            "",
            " The dispatch origin for this call must be _Signed_ and a member.",
            "",
            " Parameters:",
            " - `who`: The user who you would like to vouch for.",
            " - `value`: The total reward to be paid between you and the candidate if they become",
            " a member in the society.",
            " - `tip`: Your cut of the total `value` payout when the candidate is inducted into",
            " the society. Tips larger than `value` will be saturated upon payout.",
            "",
            " # <weight>",
            " Key: B (len of bids), C (len of candidates), M (len of members)",
            " - Storage Reads:",
            " \t- One storage read to retrieve all members. O(M)",
            " \t- One storage read to check member is not already vouching. O(1)",
            " \t- One storage read to check for suspended candidate. O(1)",
            " \t- One storage read to check for suspended member. O(1)",
            " \t- One storage read to retrieve all current bids. O(B)",
            " \t- One storage read to retrieve all current candidates. O(C)",
            " - Storage Writes:",
            " \t- One storage write to insert vouching status to the member. O(1)",
            " \t- One storage mutate to add a new bid to the vector O(B) (TODO: possible optimization w\/ read)",
            " \t- Up to one storage removal if bid.len() > MAX_BID_COUNT. O(1)",
            " - Notable Computation:",
            " \t- O(log M) search to check sender is a member.",
            " \t- O(B + C + log M) search to check user is not already a part of society.",
            " \t- O(log B) search to insert the new bid sorted.",
            " - External Module Operations:",
            " \t- One balance reserve operation. O(X)",
            " \t- Up to one balance unreserve operation if bids.len() > MAX_BID_COUNT.",
            " - Events:",
            " \t- One event for vouch.",
            " \t- Up to one event for AutoUnbid if bid.len() > MAX_BID_COUNT.",
            "",
            " Total Complexity: O(M + B + C + logM + logB + X)",
            " # <\/weight>"
          ],
          "look_up": "1a02"
        },
        {
          "name": "unvouch",
          "args": [
            {
              "name": "pos",
              "type": "u32"
            }
          ],
          "docs": [
            " As a vouching member, unvouch a bid. This only works while vouched user is",
            " only a bidder (and not a candidate).",
            "",
            " The dispatch origin for this call must be _Signed_ and a vouching member.",
            "",
            " Parameters:",
            " - `pos`: Position in the `Bids` vector of the bid who should be unvouched.",
            "",
            " # <weight>",
            " Key: B (len of bids)",
            " - One storage read O(1) to check the signer is a vouching member.",
            " - One storage mutate to retrieve and update the bids. O(B)",
            " - One vouching storage removal. O(1)",
            " - One event.",
            "",
            " Total Complexity: O(B)",
            " # <\/weight>"
          ],
          "look_up": "1a03"
        },
        {
          "name": "vote",
          "args": [
            {
              "name": "candidate",
              "type": "<T::Lookup as StaticLookup>::Source"
            },
            {
              "name": "approve",
              "type": "bool"
            }
          ],
          "docs": [
            " As a member, vote on a candidate.",
            "",
            " The dispatch origin for this call must be _Signed_ and a member.",
            "",
            " Parameters:",
            " - `candidate`: The candidate that the member would like to bid on.",
            " - `approve`: A boolean which says if the candidate should be",
            "              approved (`true`) or rejected (`false`).",
            "",
            " # <weight>",
            " Key: C (len of candidates), M (len of members)",
            " - One storage read O(M) and O(log M) search to check user is a member.",
            " - One account lookup.",
            " - One storage read O(C) and O(C) search to check that user is a candidate.",
            " - One storage write to add vote to votes. O(1)",
            " - One event.",
            "",
            " Total Complexity: O(M + logM + C)",
            " # <\/weight>"
          ],
          "look_up": "1a04"
        },
        {
          "name": "defender_vote",
          "args": [
            {
              "name": "approve",
              "type": "bool"
            }
          ],
          "docs": [
            " As a member, vote on the defender.",
            "",
            " The dispatch origin for this call must be _Signed_ and a member.",
            "",
            " Parameters:",
            " - `approve`: A boolean which says if the candidate should be",
            " approved (`true`) or rejected (`false`).",
            "",
            " # <weight>",
            " - Key: M (len of members)",
            " - One storage read O(M) and O(log M) search to check user is a member.",
            " - One storage write to add vote to votes. O(1)",
            " - One event.",
            "",
            " Total Complexity: O(M + logM)",
            " # <\/weight>"
          ],
          "look_up": "1a05"
        },
        {
          "name": "payout",
          "args": [],
          "docs": [
            " Transfer the first matured payout for the sender and remove it from the records.",
            "",
            " NOTE: This extrinsic needs to be called multiple times to claim multiple matured payouts.",
            "",
            " Payment: The member will receive a payment equal to their first matured",
            " payout to their free balance.",
            "",
            " The dispatch origin for this call must be _Signed_ and a member with",
            " payouts remaining.",
            "",
            " # <weight>",
            " Key: M (len of members), P (number of payouts for a particular member)",
            " - One storage read O(M) and O(log M) search to check signer is a member.",
            " - One storage read O(P) to get all payouts for a member.",
            " - One storage read O(1) to get the current block number.",
            " - One currency transfer call. O(X)",
            " - One storage write or removal to update the member's payouts. O(P)",
            "",
            " Total Complexity: O(M + logM + P + X)",
            " # <\/weight>"
          ],
          "look_up": "1a06"
        },
        {
          "name": "found",
          "args": [
            {
              "name": "founder",
              "type": "T::AccountId"
            },
            {
              "name": "max_members",
              "type": "u32"
            },
            {
              "name": "rules",
              "type": "Vec<u8>"
            }
          ],
          "docs": [
            " Found the society.",
            "",
            " This is done as a discrete action in order to allow for the",
            " module to be included into a running chain and can only be done once.",
            "",
            " The dispatch origin for this call must be from the _FounderSetOrigin_.",
            "",
            " Parameters:",
            " - `founder` - The first member and head of the newly founded society.",
            " - `max_members` - The initial max number of members for the society.",
            " - `rules` - The rules of this society concerning membership.",
            "",
            " # <weight>",
            " - Two storage mutates to set `Head` and `Founder`. O(1)",
            " - One storage write to add the first member to society. O(1)",
            " - One event.",
            "",
            " Total Complexity: O(1)",
            " # <\/weight>"
          ],
          "look_up": "1a07"
        },
        {
          "name": "unfound",
          "args": [],
          "docs": [
            " Annul the founding of the society.",
            "",
            " The dispatch origin for this call must be Signed, and the signing account must be both",
            " the `Founder` and the `Head`. This implies that it may only be done when there is one",
            " member.",
            "",
            " # <weight>",
            " - Two storage reads O(1).",
            " - Four storage removals O(1).",
            " - One event.",
            "",
            " Total Complexity: O(1)",
            " # <\/weight>"
          ],
          "look_up": "1a08"
        },
        {
          "name": "judge_suspended_member",
          "args": [
            {
              "name": "who",
              "type": "T::AccountId"
            },
            {
              "name": "forgive",
              "type": "bool"
            }
          ],
          "docs": [
            " Allow suspension judgement origin to make judgement on a suspended member.",
            "",
            " If a suspended member is forgiven, we simply add them back as a member, not affecting",
            " any of the existing storage items for that member.",
            "",
            " If a suspended member is rejected, remove all associated storage items, including",
            " their payouts, and remove any vouched bids they currently have.",
            "",
            " The dispatch origin for this call must be from the _SuspensionJudgementOrigin_.",
            "",
            " Parameters:",
            " - `who` - The suspended member to be judged.",
            " - `forgive` - A boolean representing whether the suspension judgement origin",
            "               forgives (`true`) or rejects (`false`) a suspended member.",
            "",
            " # <weight>",
            " Key: B (len of bids), M (len of members)",
            " - One storage read to check `who` is a suspended member. O(1)",
            " - Up to one storage write O(M) with O(log M) binary search to add a member back to society.",
            " - Up to 3 storage removals O(1) to clean up a removed member.",
            " - Up to one storage write O(B) with O(B) search to remove vouched bid from bids.",
            " - Up to one additional event if unvouch takes place.",
            " - One storage removal. O(1)",
            " - One event for the judgement.",
            "",
            " Total Complexity: O(M + logM + B)",
            " # <\/weight>"
          ],
          "look_up": "1a09"
        },
        {
          "name": "judge_suspended_candidate",
          "args": [
            {
              "name": "who",
              "type": "T::AccountId"
            },
            {
              "name": "judgement",
              "type": "Judgement"
            }
          ],
          "docs": [
            " Allow suspended judgement origin to make judgement on a suspended candidate.",
            "",
            " If the judgement is `Approve`, we add them to society as a member with the appropriate",
            " payment for joining society.",
            "",
            " If the judgement is `Reject`, we either slash the deposit of the bid, giving it back",
            " to the society treasury, or we ban the voucher from vouching again.",
            "",
            " If the judgement is `Rebid`, we put the candidate back in the bid pool and let them go",
            " through the induction process again.",
            "",
            " The dispatch origin for this call must be from the _SuspensionJudgementOrigin_.",
            "",
            " Parameters:",
            " - `who` - The suspended candidate to be judged.",
            " - `judgement` - `Approve`, `Reject`, or `Rebid`.",
            "",
            " # <weight>",
            " Key: B (len of bids), M (len of members), X (balance action)",
            " - One storage read to check `who` is a suspended candidate.",
            " - One storage removal of the suspended candidate.",
            " - Approve Logic",
            " \t- One storage read to get the available pot to pay users with. O(1)",
            " \t- One storage write to update the available pot. O(1)",
            " \t- One storage read to get the current block number. O(1)",
            " \t- One storage read to get all members. O(M)",
            " \t- Up to one unreserve currency action.",
            " \t- Up to two new storage writes to payouts.",
            " \t- Up to one storage write with O(log M) binary search to add a member to society.",
            " - Reject Logic",
            " \t- Up to one repatriate reserved currency action. O(X)",
            " \t- Up to one storage write to ban the vouching member from vouching again.",
            " - Rebid Logic",
            " \t- Storage mutate with O(log B) binary search to place the user back into bids.",
            " - Up to one additional event if unvouch takes place.",
            " - One storage removal.",
            " - One event for the judgement.",
            "",
            " Total Complexity: O(M + logM + B + X)",
            " # <\/weight>"
          ],
          "look_up": "1a0a"
        },
        {
          "name": "set_max_members",
          "args": [
            {
              "name": "max",
              "type": "u32"
            }
          ],
          "docs": [
            " Allows root origin to change the maximum number of members in society.",
            " Max membership count must be greater than 1.",
            "",
            " The dispatch origin for this call must be from _ROOT_.",
            "",
            " Parameters:",
            " - `max` - The maximum number of members for the society.",
            "",
            " # <weight>",
            " - One storage write to update the max. O(1)",
            " - One event.",
            "",
            " Total Complexity: O(1)",
            " # <\/weight>"
          ],
          "look_up": "1a0b"
        }
      ],
      "events": [
        {
          "name": "Founded",
          "args": [
            "AccountId"
          ],
          "docs": [
            " The society is founded by the given identity. [founder]"
          ],
          "look_up": "1a00"
        },
        {
          "name": "Bid",
          "args": [
            "AccountId",
            "Balance"
          ],
          "docs": [
            " A membership bid just happened. The given account is the candidate's ID and their offer",
            " is the second. [candidate_id, offer]"
          ],
          "look_up": "1a01"
        },
        {
          "name": "Vouch",
          "args": [
            "AccountId",
            "Balance",
            "AccountId"
          ],
          "docs": [
            " A membership bid just happened by vouching. The given account is the candidate's ID and",
            " their offer is the second. The vouching party is the third. [candidate_id, offer, vouching]"
          ],
          "look_up": "1a02"
        },
        {
          "name": "AutoUnbid",
          "args": [
            "AccountId"
          ],
          "docs": [
            " A [candidate] was dropped (due to an excess of bids in the system)."
          ],
          "look_up": "1a03"
        },
        {
          "name": "Unbid",
          "args": [
            "AccountId"
          ],
          "docs": [
            " A [candidate] was dropped (by their request)."
          ],
          "look_up": "1a04"
        },
        {
          "name": "Unvouch",
          "args": [
            "AccountId"
          ],
          "docs": [
            " A [candidate] was dropped (by request of who vouched for them)."
          ],
          "look_up": "1a05"
        },
        {
          "name": "Inducted",
          "args": [
            "AccountId",
            "Vec<AccountId>"
          ],
          "docs": [
            " A group of candidates have been inducted. The batch's primary is the first value, the",
            " batch in full is the second. [primary, candidates]"
          ],
          "look_up": "1a06"
        },
        {
          "name": "SuspendedMemberJudgement",
          "args": [
            "AccountId",
            "bool"
          ],
          "docs": [
            " A suspended member has been judged. [who, judged]"
          ],
          "look_up": "1a07"
        },
        {
          "name": "CandidateSuspended",
          "args": [
            "AccountId"
          ],
          "docs": [
            " A [candidate] has been suspended"
          ],
          "look_up": "1a08"
        },
        {
          "name": "MemberSuspended",
          "args": [
            "AccountId"
          ],
          "docs": [
            " A [member] has been suspended"
          ],
          "look_up": "1a09"
        },
        {
          "name": "Challenged",
          "args": [
            "AccountId"
          ],
          "docs": [
            " A [member] has been challenged"
          ],
          "look_up": "1a0a"
        },
        {
          "name": "Vote",
          "args": [
            "AccountId",
            "AccountId",
            "bool"
          ],
          "docs": [
            " A vote has been placed [candidate, voter, vote]"
          ],
          "look_up": "1a0b"
        },
        {
          "name": "DefenderVote",
          "args": [
            "AccountId",
            "bool"
          ],
          "docs": [
            " A vote has been placed for a defending member [voter, vote]"
          ],
          "look_up": "1a0c"
        },
        {
          "name": "NewMaxMembers",
          "args": [
            "u32"
          ],
          "docs": [
            " A new [max] member count has been set"
          ],
          "look_up": "1a0d"
        },
        {
          "name": "Unfounded",
          "args": [
            "AccountId"
          ],
          "docs": [
            " Society is unfounded. [founder]"
          ],
          "look_up": "1a0e"
        },
        {
          "name": "Deposit",
          "args": [
            "Balance"
          ],
          "docs": [
            " Some funds were deposited into the society account. [value]"
          ],
          "look_up": "1a0f"
        }
      ],
      "errors": [
        {
          "name": "BadPosition",
          "docs": [
            " An incorrect position was provided."
          ]
        },
        {
          "name": "NotMember",
          "docs": [
            " User is not a member."
          ]
        },
        {
          "name": "AlreadyMember",
          "docs": [
            " User is already a member."
          ]
        },
        {
          "name": "Suspended",
          "docs": [
            " User is suspended."
          ]
        },
        {
          "name": "NotSuspended",
          "docs": [
            " User is not suspended."
          ]
        },
        {
          "name": "NoPayout",
          "docs": [
            " Nothing to payout."
          ]
        },
        {
          "name": "AlreadyFounded",
          "docs": [
            " Society already founded."
          ]
        },
        {
          "name": "InsufficientPot",
          "docs": [
            " Not enough in pot to accept candidate."
          ]
        },
        {
          "name": "AlreadyVouching",
          "docs": [
            " Member is already vouching or banned from vouching again."
          ]
        },
        {
          "name": "NotVouching",
          "docs": [
            " Member is not vouching."
          ]
        },
        {
          "name": "Head",
          "docs": [
            " Cannot remove the head of the chain."
          ]
        },
        {
          "name": "Founder",
          "docs": [
            " Cannot remove the founder."
          ]
        },
        {
          "name": "AlreadyBid",
          "docs": [
            " User has already made a bid."
          ]
        },
        {
          "name": "AlreadyCandidate",
          "docs": [
            " User is already a candidate."
          ]
        },
        {
          "name": "NotCandidate",
          "docs": [
            " User is not a candidate."
          ]
        },
        {
          "name": "MaxMembers",
          "docs": [
            " Too many members in the society."
          ]
        },
        {
          "name": "NotFounder",
          "docs": [
            " The caller is not the founder."
          ]
        },
        {
          "name": "NotHead",
          "docs": [
            " The caller is not the head."
          ]
        }
      ],
      "constants": [
        {
          "name": "CandidateDeposit",
          "type": "BalanceOf<T, I>",
          "value": "0080c6a47e8d03000000000000000000",
          "docs": [
            " The minimum amount of a deposit required for a bid to be made."
          ]
        },
        {
          "name": "WrongSideDeduction",
          "type": "BalanceOf<T, I>",
          "value": "0080f420e6b500000000000000000000",
          "docs": [
            " The amount of the unpaid reward that gets deducted in the case that either a skeptic",
            " doesn't vote or someone votes in the wrong way."
          ]
        },
        {
          "name": "MaxStrikes",
          "type": "u32",
          "value": "0a000000",
          "docs": [
            " The number of times a member may vote the wrong way (or not at all, when they are a skeptic)",
            " before they become suspended."
          ]
        },
        {
          "name": "PeriodSpend",
          "type": "BalanceOf<T, I>",
          "value": "0000c52ebca2b1000000000000000000",
          "docs": [
            " The amount of incentive paid within each period. Doesn't include VoterTip."
          ]
        },
        {
          "name": "RotationPeriod",
          "type": "T::BlockNumber",
          "value": "00770100",
          "docs": [
            " The number of blocks between candidate\/membership rotation periods."
          ]
        },
        {
          "name": "ChallengePeriod",
          "type": "T::BlockNumber",
          "value": "80130300",
          "docs": [
            " The number of blocks between membership challenges."
          ]
        },
        {
          "name": "ModuleId",
          "type": "ModuleId",
          "value": "70792f736f636965",
          "docs": [
            " The societies's module id"
          ]
        }
      ],
      "index": 26
    },
    {
      "name": "Recovery",
      "prefix": "Recovery",
      "calls": [
        {
          "name": "as_recovered",
          "args": [
            {
              "name": "account",
              "type": "T::AccountId"
            },
            {
              "name": "call",
              "type": "Box<<T as Trait>::Call>"
            }
          ],
          "docs": [
            " Send a call through a recovered account.",
            "",
            " The dispatch origin for this call must be _Signed_ and registered to",
            " be able to make calls on behalf of the recovered account.",
            "",
            " Parameters:",
            " - `account`: The recovered account you want to make a call on-behalf-of.",
            " - `call`: The call you want to make with the recovered account.",
            "",
            " # <weight>",
            " - The weight of the `call` + 10,000.",
            " - One storage lookup to check account is recovered by `who`. O(1)",
            " # <\/weight>"
          ],
          "look_up": "1b00"
        },
        {
          "name": "set_recovered",
          "args": [
            {
              "name": "lost",
              "type": "T::AccountId"
            },
            {
              "name": "rescuer",
              "type": "T::AccountId"
            }
          ],
          "docs": [
            " Allow ROOT to bypass the recovery process and set an a rescuer account",
            " for a lost account directly.",
            "",
            " The dispatch origin for this call must be _ROOT_.",
            "",
            " Parameters:",
            " - `lost`: The \"lost account\" to be recovered.",
            " - `rescuer`: The \"rescuer account\" which can call as the lost account.",
            "",
            " # <weight>",
            " - One storage write O(1)",
            " - One event",
            " # <\/weight>"
          ],
          "look_up": "1b01"
        },
        {
          "name": "create_recovery",
          "args": [
            {
              "name": "friends",
              "type": "Vec<T::AccountId>"
            },
            {
              "name": "threshold",
              "type": "u16"
            },
            {
              "name": "delay_period",
              "type": "T::BlockNumber"
            }
          ],
          "docs": [
            " Create a recovery configuration for your account. This makes your account recoverable.",
            "",
            " Payment: `ConfigDepositBase` + `FriendDepositFactor` * #_of_friends balance",
            " will be reserved for storing the recovery configuration. This deposit is returned",
            " in full when the user calls `remove_recovery`.",
            "",
            " The dispatch origin for this call must be _Signed_.",
            "",
            " Parameters:",
            " - `friends`: A list of friends you trust to vouch for recovery attempts.",
            "   Should be ordered and contain no duplicate values.",
            " - `threshold`: The number of friends that must vouch for a recovery attempt",
            "   before the account can be recovered. Should be less than or equal to",
            "   the length of the list of friends.",
            " - `delay_period`: The number of blocks after a recovery attempt is initialized",
            "   that needs to pass before the account can be recovered.",
            "",
            " # <weight>",
            " - Key: F (len of friends)",
            " - One storage read to check that account is not already recoverable. O(1).",
            " - A check that the friends list is sorted and unique. O(F)",
            " - One currency reserve operation. O(X)",
            " - One storage write. O(1). Codec O(F).",
            " - One event.",
            "",
            " Total Complexity: O(F + X)",
            " # <\/weight>"
          ],
          "look_up": "1b02"
        },
        {
          "name": "initiate_recovery",
          "args": [
            {
              "name": "account",
              "type": "T::AccountId"
            }
          ],
          "docs": [
            " Initiate the process for recovering a recoverable account.",
            "",
            " Payment: `RecoveryDeposit` balance will be reserved for initiating the",
            " recovery process. This deposit will always be repatriated to the account",
            " trying to be recovered. See `close_recovery`.",
            "",
            " The dispatch origin for this call must be _Signed_.",
            "",
            " Parameters:",
            " - `account`: The lost account that you want to recover. This account",
            "   needs to be recoverable (i.e. have a recovery configuration).",
            "",
            " # <weight>",
            " - One storage read to check that account is recoverable. O(F)",
            " - One storage read to check that this recovery process hasn't already started. O(1)",
            " - One currency reserve operation. O(X)",
            " - One storage read to get the current block number. O(1)",
            " - One storage write. O(1).",
            " - One event.",
            "",
            " Total Complexity: O(F + X)",
            " # <\/weight>"
          ],
          "look_up": "1b03"
        },
        {
          "name": "vouch_recovery",
          "args": [
            {
              "name": "lost",
              "type": "T::AccountId"
            },
            {
              "name": "rescuer",
              "type": "T::AccountId"
            }
          ],
          "docs": [
            " Allow a \"friend\" of a recoverable account to vouch for an active recovery",
            " process for that account.",
            "",
            " The dispatch origin for this call must be _Signed_ and must be a \"friend\"",
            " for the recoverable account.",
            "",
            " Parameters:",
            " - `lost`: The lost account that you want to recover.",
            " - `rescuer`: The account trying to rescue the lost account that you",
            "   want to vouch for.",
            "",
            " The combination of these two parameters must point to an active recovery",
            " process.",
            "",
            " # <weight>",
            " Key: F (len of friends in config), V (len of vouching friends)",
            " - One storage read to get the recovery configuration. O(1), Codec O(F)",
            " - One storage read to get the active recovery process. O(1), Codec O(V)",
            " - One binary search to confirm caller is a friend. O(logF)",
            " - One binary search to confirm caller has not already vouched. O(logV)",
            " - One storage write. O(1), Codec O(V).",
            " - One event.",
            "",
            " Total Complexity: O(F + logF + V + logV)",
            " # <\/weight>"
          ],
          "look_up": "1b04"
        },
        {
          "name": "claim_recovery",
          "args": [
            {
              "name": "account",
              "type": "T::AccountId"
            }
          ],
          "docs": [
            " Allow a successful rescuer to claim their recovered account.",
            "",
            " The dispatch origin for this call must be _Signed_ and must be a \"rescuer\"",
            " who has successfully completed the account recovery process: collected",
            " `threshold` or more vouches, waited `delay_period` blocks since initiation.",
            "",
            " Parameters:",
            " - `account`: The lost account that you want to claim has been successfully",
            "   recovered by you.",
            "",
            " # <weight>",
            " Key: F (len of friends in config), V (len of vouching friends)",
            " - One storage read to get the recovery configuration. O(1), Codec O(F)",
            " - One storage read to get the active recovery process. O(1), Codec O(V)",
            " - One storage read to get the current block number. O(1)",
            " - One storage write. O(1), Codec O(V).",
            " - One event.",
            "",
            " Total Complexity: O(F + V)",
            " # <\/weight>"
          ],
          "look_up": "1b05"
        },
        {
          "name": "close_recovery",
          "args": [
            {
              "name": "rescuer",
              "type": "T::AccountId"
            }
          ],
          "docs": [
            " As the controller of a recoverable account, close an active recovery",
            " process for your account.",
            "",
            " Payment: By calling this function, the recoverable account will receive",
            " the recovery deposit `RecoveryDeposit` placed by the rescuer.",
            "",
            " The dispatch origin for this call must be _Signed_ and must be a",
            " recoverable account with an active recovery process for it.",
            "",
            " Parameters:",
            " - `rescuer`: The account trying to rescue this recoverable account.",
            "",
            " # <weight>",
            " Key: V (len of vouching friends)",
            " - One storage read\/remove to get the active recovery process. O(1), Codec O(V)",
            " - One balance call to repatriate reserved. O(X)",
            " - One event.",
            "",
            " Total Complexity: O(V + X)",
            " # <\/weight>"
          ],
          "look_up": "1b06"
        },
        {
          "name": "remove_recovery",
          "args": [],
          "docs": [
            " Remove the recovery process for your account. Recovered accounts are still accessible.",
            "",
            " NOTE: The user must make sure to call `close_recovery` on all active",
            " recovery attempts before calling this function else it will fail.",
            "",
            " Payment: By calling this function the recoverable account will unreserve",
            " their recovery configuration deposit.",
            " (`ConfigDepositBase` + `FriendDepositFactor` * #_of_friends)",
            "",
            " The dispatch origin for this call must be _Signed_ and must be a",
            " recoverable account (i.e. has a recovery configuration).",
            "",
            " # <weight>",
            " Key: F (len of friends)",
            " - One storage read to get the prefix iterator for active recoveries. O(1)",
            " - One storage read\/remove to get the recovery configuration. O(1), Codec O(F)",
            " - One balance call to unreserved. O(X)",
            " - One event.",
            "",
            " Total Complexity: O(F + X)",
            " # <\/weight>"
          ],
          "look_up": "1b07"
        },
        {
          "name": "cancel_recovered",
          "args": [
            {
              "name": "account",
              "type": "T::AccountId"
            }
          ],
          "docs": [
            " Cancel the ability to use `as_recovered` for `account`.",
            "",
            " The dispatch origin for this call must be _Signed_ and registered to",
            " be able to make calls on behalf of the recovered account.",
            "",
            " Parameters:",
            " - `account`: The recovered account you are able to call on-behalf-of.",
            "",
            " # <weight>",
            " - One storage mutation to check account is recovered by `who`. O(1)",
            " # <\/weight>"
          ],
          "look_up": "1b08"
        }
      ],
      "events": [
        {
          "name": "RecoveryCreated",
          "args": [
            "AccountId"
          ],
          "docs": [
            " A recovery process has been set up for an [account]."
          ],
          "look_up": "1b00"
        },
        {
          "name": "RecoveryInitiated",
          "args": [
            "AccountId",
            "AccountId"
          ],
          "docs": [
            " A recovery process has been initiated for lost account by rescuer account.",
            " [lost, rescuer]"
          ],
          "look_up": "1b01"
        },
        {
          "name": "RecoveryVouched",
          "args": [
            "AccountId",
            "AccountId",
            "AccountId"
          ],
          "docs": [
            " A recovery process for lost account by rescuer account has been vouched for by sender.",
            " [lost, rescuer, sender]"
          ],
          "look_up": "1b02"
        },
        {
          "name": "RecoveryClosed",
          "args": [
            "AccountId",
            "AccountId"
          ],
          "docs": [
            " A recovery process for lost account by rescuer account has been closed.",
            " [lost, rescuer]"
          ],
          "look_up": "1b03"
        },
        {
          "name": "AccountRecovered",
          "args": [
            "AccountId",
            "AccountId"
          ],
          "docs": [
            " Lost account has been successfully recovered by rescuer account.",
            " [lost, rescuer]"
          ],
          "look_up": "1b04"
        },
        {
          "name": "RecoveryRemoved",
          "args": [
            "AccountId"
          ],
          "docs": [
            " A recovery process has been removed for an [account]."
          ],
          "look_up": "1b05"
        }
      ],
      "errors": [
        {
          "name": "NotAllowed",
          "docs": [
            " User is not allowed to make a call on behalf of this account"
          ]
        },
        {
          "name": "ZeroThreshold",
          "docs": [
            " Threshold must be greater than zero"
          ]
        },
        {
          "name": "NotEnoughFriends",
          "docs": [
            " Friends list must be greater than zero and threshold"
          ]
        },
        {
          "name": "MaxFriends",
          "docs": [
            " Friends list must be less than max friends"
          ]
        },
        {
          "name": "NotSorted",
          "docs": [
            " Friends list must be sorted and free of duplicates"
          ]
        },
        {
          "name": "NotRecoverable",
          "docs": [
            " This account is not set up for recovery"
          ]
        },
        {
          "name": "AlreadyRecoverable",
          "docs": [
            " This account is already set up for recovery"
          ]
        },
        {
          "name": "AlreadyStarted",
          "docs": [
            " A recovery process has already started for this account"
          ]
        },
        {
          "name": "NotStarted",
          "docs": [
            " A recovery process has not started for this rescuer"
          ]
        },
        {
          "name": "NotFriend",
          "docs": [
            " This account is not a friend who can vouch"
          ]
        },
        {
          "name": "DelayPeriod",
          "docs": [
            " The friend must wait until the delay period to vouch for this recovery"
          ]
        },
        {
          "name": "AlreadyVouched",
          "docs": [
            " This user has already vouched for this recovery"
          ]
        },
        {
          "name": "Threshold",
          "docs": [
            " The threshold for recovering this account has not been met"
          ]
        },
        {
          "name": "StillActive",
          "docs": [
            " There are still active recovery attempts that need to be closed"
          ]
        },
        {
          "name": "Overflow",
          "docs": [
            " There was an overflow in a calculation"
          ]
        },
        {
          "name": "AlreadyProxy",
          "docs": [
            " This account is already set up for recovery"
          ]
        }
      ],
      "constants": [
        {
          "name": "ConfigDepositBase",
          "type": "BalanceOf<T>",
          "value": "00406352bfc601000000000000000000",
          "docs": [
            " The base amount of currency needed to reserve for creating a recovery configuration."
          ]
        },
        {
          "name": "FriendDepositFactor",
          "type": "BalanceOf<T>",
          "value": "00203d88792d00000000000000000000",
          "docs": [
            " The amount of currency needed per additional user when creating a recovery configuration."
          ]
        },
        {
          "name": "MaxFriends",
          "type": "u16",
          "value": "0900",
          "docs": [
            " The maximum amount of friends allowed in a recovery configuration."
          ]
        },
        {
          "name": "RecoveryDeposit",
          "type": "BalanceOf<T>",
          "value": "00406352bfc601000000000000000000",
          "docs": [
            " The base amount of currency needed to reserve for starting a recovery."
          ]
        }
      ],
      "index": 27
    },
    {
      "name": "Vesting",
      "prefix": "Vesting",
      "calls": [
        {
          "name": "vest",
          "args": [],
          "docs": [
            " Unlock any vested funds of the sender account.",
            "",
            " The dispatch origin for this call must be _Signed_ and the sender must have funds still",
            " locked under this module.",
            "",
            " Emits either `VestingCompleted` or `VestingUpdated`.",
            "",
            " # <weight>",
            " - `O(1)`.",
            " - DbWeight: 2 Reads, 2 Writes",
            "     - Reads: Vesting Storage, Balances Locks, [Sender Account]",
            "     - Writes: Vesting Storage, Balances Locks, [Sender Account]",
            " - Benchmark:",
            "     - Unlocked: 48.76 + .048 * l \u00b5s (min square analysis)",
            "     - Locked: 44.43 + .284 * l \u00b5s (min square analysis)",
            " - Using 50 \u00b5s fixed. Assuming less than 50 locks on any user, else we may want factor in number of locks.",
            " # <\/weight>"
          ],
          "look_up": "1c00"
        },
        {
          "name": "vest_other",
          "args": [
            {
              "name": "target",
              "type": "<T::Lookup as StaticLookup>::Source"
            }
          ],
          "docs": [
            " Unlock any vested funds of a `target` account.",
            "",
            " The dispatch origin for this call must be _Signed_.",
            "",
            " - `target`: The account whose vested funds should be unlocked. Must have funds still",
            " locked under this module.",
            "",
            " Emits either `VestingCompleted` or `VestingUpdated`.",
            "",
            " # <weight>",
            " - `O(1)`.",
            " - DbWeight: 3 Reads, 3 Writes",
            "     - Reads: Vesting Storage, Balances Locks, Target Account",
            "     - Writes: Vesting Storage, Balances Locks, Target Account",
            " - Benchmark:",
            "     - Unlocked: 44.3 + .294 * l \u00b5s (min square analysis)",
            "     - Locked: 48.16 + .103 * l \u00b5s (min square analysis)",
            " - Using 50 \u00b5s fixed. Assuming less than 50 locks on any user, else we may want factor in number of locks.",
            " # <\/weight>"
          ],
          "look_up": "1c01"
        },
        {
          "name": "vested_transfer",
          "args": [
            {
              "name": "target",
              "type": "<T::Lookup as StaticLookup>::Source"
            },
            {
              "name": "schedule",
              "type": "VestingInfo<BalanceOf<T>, T::BlockNumber>"
            }
          ],
          "docs": [
            " Create a vested transfer.",
            "",
            " The dispatch origin for this call must be _Signed_.",
            "",
            " - `target`: The account that should be transferred the vested funds.",
            " - `amount`: The amount of funds to transfer and will be vested.",
            " - `schedule`: The vesting schedule attached to the transfer.",
            "",
            " Emits `VestingCreated`.",
            "",
            " # <weight>",
            " - `O(1)`.",
            " - DbWeight: 3 Reads, 3 Writes",
            "     - Reads: Vesting Storage, Balances Locks, Target Account, [Sender Account]",
            "     - Writes: Vesting Storage, Balances Locks, Target Account, [Sender Account]",
            " - Benchmark: 100.3 + .365 * l \u00b5s (min square analysis)",
            " - Using 100 \u00b5s fixed. Assuming less than 50 locks on any user, else we may want factor in number of locks.",
            " # <\/weight>"
          ],
          "look_up": "1c02"
        },
        {
          "name": "force_vested_transfer",
          "args": [
            {
              "name": "source",
              "type": "<T::Lookup as StaticLookup>::Source"
            },
            {
              "name": "target",
              "type": "<T::Lookup as StaticLookup>::Source"
            },
            {
              "name": "schedule",
              "type": "VestingInfo<BalanceOf<T>, T::BlockNumber>"
            }
          ],
          "docs": [
            " Force a vested transfer.",
            "",
            " The dispatch origin for this call must be _Root_.",
            "",
            " - `source`: The account whose funds should be transferred.",
            " - `target`: The account that should be transferred the vested funds.",
            " - `amount`: The amount of funds to transfer and will be vested.",
            " - `schedule`: The vesting schedule attached to the transfer.",
            "",
            " Emits `VestingCreated`.",
            "",
            " # <weight>",
            " - `O(1)`.",
            " - DbWeight: 4 Reads, 4 Writes",
            "     - Reads: Vesting Storage, Balances Locks, Target Account, Source Account",
            "     - Writes: Vesting Storage, Balances Locks, Target Account, Source Account",
            " - Benchmark: 100.3 + .365 * l \u00b5s (min square analysis)",
            " - Using 100 \u00b5s fixed. Assuming less than 50 locks on any user, else we may want factor in number of locks.",
            " # <\/weight>"
          ],
          "look_up": "1c03"
        }
      ],
      "events": [
        {
          "name": "VestingUpdated",
          "args": [
            "AccountId",
            "Balance"
          ],
          "docs": [
            " The amount vested has been updated. This could indicate more funds are available. The",
            " balance given is the amount which is left unvested (and thus locked). ",
            " [account, unvested]"
          ],
          "look_up": "1c00"
        },
        {
          "name": "VestingCompleted",
          "args": [
            "AccountId"
          ],
          "docs": [
            " An [account] has become fully vested. No further vesting can happen."
          ],
          "look_up": "1c01"
        }
      ],
      "errors": [
        {
          "name": "NotVesting",
          "docs": [
            " The account given is not vesting."
          ]
        },
        {
          "name": "ExistingVestingSchedule",
          "docs": [
            " An existing vesting schedule already exists for this account that cannot be clobbered."
          ]
        },
        {
          "name": "AmountLow",
          "docs": [
            " Amount being transferred is too low to create a vesting schedule."
          ]
        }
      ],
      "constants": [
        {
          "name": "MinVestedTransfer",
          "type": "BalanceOf<T>",
          "value": "0000c16ff28623000000000000000000",
          "docs": [
            " The minimum amount to be transferred to create a new vesting schedule."
          ]
        }
      ],
      "index": 28
    },
    {
      "name": "Scheduler",
      "prefix": "Scheduler",
      "calls": [
        {
          "name": "schedule",
          "args": [
            {
              "name": "when",
              "type": "T::BlockNumber"
            },
            {
              "name": "maybe_periodic",
              "type": "Option<schedule::Period<T::BlockNumber>>"
            },
            {
              "name": "priority",
              "type": "schedule::Priority"
            },
            {
              "name": "call",
              "type": "Box<<T as Trait>::Call>"
            }
          ],
          "docs": [
            " Anonymously schedule a task.",
            "",
            " # <weight>",
            " - S = Number of already scheduled calls",
            " - Base Weight: 22.29 + .126 * S \u00b5s",
            " - DB Weight:",
            "     - Read: Agenda",
            "     - Write: Agenda",
            " - Will use base weight of 25 which should be good for up to 30 scheduled calls",
            " # <\/weight>"
          ],
          "look_up": "1d00"
        },
        {
          "name": "cancel",
          "args": [
            {
              "name": "when",
              "type": "T::BlockNumber"
            },
            {
              "name": "index",
              "type": "u32"
            }
          ],
          "docs": [
            " Cancel an anonymously scheduled task.",
            "",
            " # <weight>",
            " - S = Number of already scheduled calls",
            " - Base Weight: 22.15 + 2.869 * S \u00b5s",
            " - DB Weight:",
            "     - Read: Agenda",
            "     - Write: Agenda, Lookup",
            " - Will use base weight of 100 which should be good for up to 30 scheduled calls",
            " # <\/weight>"
          ],
          "look_up": "1d01"
        },
        {
          "name": "schedule_named",
          "args": [
            {
              "name": "id",
              "type": "Vec<u8>"
            },
            {
              "name": "when",
              "type": "T::BlockNumber"
            },
            {
              "name": "maybe_periodic",
              "type": "Option<schedule::Period<T::BlockNumber>>"
            },
            {
              "name": "priority",
              "type": "schedule::Priority"
            },
            {
              "name": "call",
              "type": "Box<<T as Trait>::Call>"
            }
          ],
          "docs": [
            " Schedule a named task.",
            "",
            " # <weight>",
            " - S = Number of already scheduled calls",
            " - Base Weight: 29.6 + .159 * S \u00b5s",
            " - DB Weight:",
            "     - Read: Agenda, Lookup",
            "     - Write: Agenda, Lookup",
            " - Will use base weight of 35 which should be good for more than 30 scheduled calls",
            " # <\/weight>"
          ],
          "look_up": "1d02"
        },
        {
          "name": "cancel_named",
          "args": [
            {
              "name": "id",
              "type": "Vec<u8>"
            }
          ],
          "docs": [
            " Cancel a named scheduled task.",
            "",
            " # <weight>",
            " - S = Number of already scheduled calls",
            " - Base Weight: 24.91 + 2.907 * S \u00b5s",
            " - DB Weight:",
            "     - Read: Agenda, Lookup",
            "     - Write: Agenda, Lookup",
            " - Will use base weight of 100 which should be good for up to 30 scheduled calls",
            " # <\/weight>"
          ],
          "look_up": "1d03"
        },
        {
          "name": "schedule_after",
          "args": [
            {
              "name": "after",
              "type": "T::BlockNumber"
            },
            {
              "name": "maybe_periodic",
              "type": "Option<schedule::Period<T::BlockNumber>>"
            },
            {
              "name": "priority",
              "type": "schedule::Priority"
            },
            {
              "name": "call",
              "type": "Box<<T as Trait>::Call>"
            }
          ],
          "docs": [
            " Anonymously schedule a task after a delay.",
            "",
            " # <weight>",
            " Same as [`schedule`].",
            " # <\/weight>"
          ],
          "look_up": "1d04"
        },
        {
          "name": "schedule_named_after",
          "args": [
            {
              "name": "id",
              "type": "Vec<u8>"
            },
            {
              "name": "after",
              "type": "T::BlockNumber"
            },
            {
              "name": "maybe_periodic",
              "type": "Option<schedule::Period<T::BlockNumber>>"
            },
            {
              "name": "priority",
              "type": "schedule::Priority"
            },
            {
              "name": "call",
              "type": "Box<<T as Trait>::Call>"
            }
          ],
          "docs": [
            " Schedule a named task after a delay.",
            "",
            " # <weight>",
            " Same as [`schedule_named`].",
            " # <\/weight>"
          ],
          "look_up": "1d05"
        }
      ],
      "events": [
        {
          "name": "Scheduled",
          "args": [
            "BlockNumber",
            "u32"
          ],
          "docs": [
            " Scheduled some task. [when, index]"
          ],
          "look_up": "1d00"
        },
        {
          "name": "Canceled",
          "args": [
            "BlockNumber",
            "u32"
          ],
          "docs": [
            " Canceled some task. [when, index]"
          ],
          "look_up": "1d01"
        },
        {
          "name": "Dispatched",
          "args": [
            "TaskAddress<BlockNumber>",
            "Option<Vec<u8>>",
            "DispatchResult"
          ],
          "docs": [
            " Dispatched some task. [task, id, result]"
          ],
          "look_up": "1d02"
        }
      ],
      "errors": [
        {
          "name": "FailedToSchedule",
          "docs": [
            " Failed to schedule a call"
          ]
        },
        {
          "name": "FailedToCancel",
          "docs": [
            " Failed to cancel a scheduled call"
          ]
        },
        {
          "name": "TargetBlockNumberInPast",
          "docs": [
            " Given target block number is in the past."
          ]
        }
      ],
      "constants": [
        {
          "name": "MinVestedTransfer",
          "type": "BalanceOf<T>",
          "value": "0000c16ff28623000000000000000000",
          "docs": [
            " The minimum amount to be transferred to create a new vesting schedule."
          ]
        }
      ],
      "index": 29
    },
    {
      "name": "Proxy",
      "prefix": "Proxy",
      "calls": [
        {
          "name": "proxy",
          "args": [
            {
              "name": "real",
              "type": "T::AccountId"
            },
            {
              "name": "force_proxy_type",
              "type": "Option<T::ProxyType>"
            },
            {
              "name": "call",
              "type": "Box<<T as Trait>::Call>"
            }
          ],
          "docs": [
            " Dispatch the given `call` from an account that the sender is authorised for through",
            " `add_proxy`.",
            "",
            " Removes any corresponding announcement(s).",
            "",
            " The dispatch origin for this call must be _Signed_.",
            "",
            " Parameters:",
            " - `real`: The account that the proxy will make a call on behalf of.",
            " - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.",
            " - `call`: The call to be made by the `real` account.",
            "",
            " # <weight>",
            " Weight is a function of the number of proxies the user has (P).",
            " # <\/weight>"
          ],
          "look_up": "1e00"
        },
        {
          "name": "add_proxy",
          "args": [
            {
              "name": "delegate",
              "type": "T::AccountId"
            },
            {
              "name": "proxy_type",
              "type": "T::ProxyType"
            },
            {
              "name": "delay",
              "type": "T::BlockNumber"
            }
          ],
          "docs": [
            " Register a proxy account for the sender that is able to make calls on its behalf.",
            "",
            " The dispatch origin for this call must be _Signed_.",
            "",
            " Parameters:",
            " - `proxy`: The account that the `caller` would like to make a proxy.",
            " - `proxy_type`: The permissions allowed for this proxy account.",
            "",
            " # <weight>",
            " Weight is a function of the number of proxies the user has (P).",
            " # <\/weight>"
          ],
          "look_up": "1e01"
        },
        {
          "name": "remove_proxy",
          "args": [
            {
              "name": "delegate",
              "type": "T::AccountId"
            },
            {
              "name": "proxy_type",
              "type": "T::ProxyType"
            },
            {
              "name": "delay",
              "type": "T::BlockNumber"
            }
          ],
          "docs": [
            " Unregister a proxy account for the sender.",
            "",
            " The dispatch origin for this call must be _Signed_.",
            "",
            " Parameters:",
            " - `proxy`: The account that the `caller` would like to remove as a proxy.",
            " - `proxy_type`: The permissions currently enabled for the removed proxy account.",
            "",
            " # <weight>",
            " Weight is a function of the number of proxies the user has (P).",
            " # <\/weight>"
          ],
          "look_up": "1e02"
        },
        {
          "name": "remove_proxies",
          "args": [],
          "docs": [
            " Unregister all proxy accounts for the sender.",
            "",
            " The dispatch origin for this call must be _Signed_.",
            "",
            " WARNING: This may be called on accounts created by `anonymous`, however if done, then",
            " the unreserved fees will be inaccessible. **All access to this account will be lost.**",
            "",
            " # <weight>",
            " Weight is a function of the number of proxies the user has (P).",
            " # <\/weight>"
          ],
          "look_up": "1e03"
        },
        {
          "name": "anonymous",
          "args": [
            {
              "name": "proxy_type",
              "type": "T::ProxyType"
            },
            {
              "name": "delay",
              "type": "T::BlockNumber"
            },
            {
              "name": "index",
              "type": "u16"
            }
          ],
          "docs": [
            " Spawn a fresh new account that is guaranteed to be otherwise inaccessible, and",
            " initialize it with a proxy of `proxy_type` for `origin` sender.",
            "",
            " Requires a `Signed` origin.",
            "",
            " - `proxy_type`: The type of the proxy that the sender will be registered as over the",
            " new account. This will almost always be the most permissive `ProxyType` possible to",
            " allow for maximum flexibility.",
            " - `index`: A disambiguation index, in case this is called multiple times in the same",
            " transaction (e.g. with `utility::batch`). Unless you're using `batch` you probably just",
            " want to use `0`.",
            " - `delay`: The announcement period required of the initial proxy. Will generally be",
            " zero.",
            "",
            " Fails with `Duplicate` if this has already been called in this transaction, from the",
            " same sender, with the same parameters.",
            "",
            " Fails if there are insufficient funds to pay for deposit.",
            "",
            " # <weight>",
            " Weight is a function of the number of proxies the user has (P).",
            " # <\/weight>",
            " TODO: Might be over counting 1 read"
          ],
          "look_up": "1e04"
        },
        {
          "name": "kill_anonymous",
          "args": [
            {
              "name": "spawner",
              "type": "T::AccountId"
            },
            {
              "name": "proxy_type",
              "type": "T::ProxyType"
            },
            {
              "name": "index",
              "type": "u16"
            },
            {
              "name": "height",
              "type": "Compact<T::BlockNumber>"
            },
            {
              "name": "ext_index",
              "type": "Compact<u32>"
            }
          ],
          "docs": [
            " Removes a previously spawned anonymous proxy.",
            "",
            " WARNING: **All access to this account will be lost.** Any funds held in it will be",
            " inaccessible.",
            "",
            " Requires a `Signed` origin, and the sender account must have been created by a call to",
            " `anonymous` with corresponding parameters.",
            "",
            " - `spawner`: The account that originally called `anonymous` to create this account.",
            " - `index`: The disambiguation index originally passed to `anonymous`. Probably `0`.",
            " - `proxy_type`: The proxy type originally passed to `anonymous`.",
            " - `height`: The height of the chain when the call to `anonymous` was processed.",
            " - `ext_index`: The extrinsic index in which the call to `anonymous` was processed.",
            "",
            " Fails with `NoPermission` in case the caller is not a previously created anonymous",
            " account whose `anonymous` call has corresponding parameters.",
            "",
            " # <weight>",
            " Weight is a function of the number of proxies the user has (P).",
            " # <\/weight>"
          ],
          "look_up": "1e05"
        },
        {
          "name": "announce",
          "args": [
            {
              "name": "real",
              "type": "T::AccountId"
            },
            {
              "name": "call_hash",
              "type": "CallHashOf<T>"
            }
          ],
          "docs": [
            " Publish the hash of a proxy-call that will be made in the future.",
            "",
            " This must be called some number of blocks before the corresponding `proxy` is attempted",
            " if the delay associated with the proxy relationship is greater than zero.",
            "",
            " No more than `MaxPending` announcements may be made at any one time.",
            "",
            " This will take a deposit of `AnnouncementDepositFactor` as well as",
            " `AnnouncementDepositBase` if there are no other pending announcements.",
            "",
            " The dispatch origin for this call must be _Signed_ and a proxy of `real`.",
            "",
            " Parameters:",
            " - `real`: The account that the proxy will make a call on behalf of.",
            " - `call_hash`: The hash of the call to be made by the `real` account.",
            "",
            " # <weight>",
            " Weight is a function of:",
            " - A: the number of announcements made.",
            " - P: the number of proxies the user has.",
            " # <\/weight>"
          ],
          "look_up": "1e06"
        },
        {
          "name": "remove_announcement",
          "args": [
            {
              "name": "real",
              "type": "T::AccountId"
            },
            {
              "name": "call_hash",
              "type": "CallHashOf<T>"
            }
          ],
          "docs": [
            " Remove a given announcement.",
            "",
            " May be called by a proxy account to remove a call they previously announced and return",
            " the deposit.",
            "",
            " The dispatch origin for this call must be _Signed_.",
            "",
            " Parameters:",
            " - `real`: The account that the proxy will make a call on behalf of.",
            " - `call_hash`: The hash of the call to be made by the `real` account.",
            "",
            " # <weight>",
            " Weight is a function of:",
            " - A: the number of announcements made.",
            " - P: the number of proxies the user has.",
            " # <\/weight>"
          ],
          "look_up": "1e07"
        },
        {
          "name": "reject_announcement",
          "args": [
            {
              "name": "delegate",
              "type": "T::AccountId"
            },
            {
              "name": "call_hash",
              "type": "CallHashOf<T>"
            }
          ],
          "docs": [
            " Remove the given announcement of a delegate.",
            "",
            " May be called by a target (proxied) account to remove a call that one of their delegates",
            " (`delegate`) has announced they want to execute. The deposit is returned.",
            "",
            " The dispatch origin for this call must be _Signed_.",
            "",
            " Parameters:",
            " - `delegate`: The account that previously announced the call.",
            " - `call_hash`: The hash of the call to be made.",
            "",
            " # <weight>",
            " Weight is a function of:",
            " - A: the number of announcements made.",
            " - P: the number of proxies the user has.",
            " # <\/weight>"
          ],
          "look_up": "1e08"
        },
        {
          "name": "proxy_announced",
          "args": [
            {
              "name": "delegate",
              "type": "T::AccountId"
            },
            {
              "name": "real",
              "type": "T::AccountId"
            },
            {
              "name": "force_proxy_type",
              "type": "Option<T::ProxyType>"
            },
            {
              "name": "call",
              "type": "Box<<T as Trait>::Call>"
            }
          ],
          "docs": [
            " Dispatch the given `call` from an account that the sender is authorised for through",
            " `add_proxy`.",
            "",
            " Removes any corresponding announcement(s).",
            "",
            " The dispatch origin for this call must be _Signed_.",
            "",
            " Parameters:",
            " - `real`: The account that the proxy will make a call on behalf of.",
            " - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.",
            " - `call`: The call to be made by the `real` account.",
            "",
            " # <weight>",
            " Weight is a function of:",
            " - A: the number of announcements made.",
            " - P: the number of proxies the user has.",
            " # <\/weight>"
          ],
          "look_up": "1e09"
        }
      ],
      "events": [
        {
          "name": "ProxyExecuted",
          "args": [
            "DispatchResult"
          ],
          "docs": [
            " A proxy was executed correctly, with the given [result]."
          ],
          "look_up": "1e00"
        },
        {
          "name": "AnonymousCreated",
          "args": [
            "AccountId",
            "AccountId",
            "ProxyType",
            "u16"
          ],
          "docs": [
            " Anonymous account has been created by new proxy with given",
            " disambiguation index and proxy type. [anonymous, who, proxy_type, disambiguation_index]"
          ],
          "look_up": "1e01"
        },
        {
          "name": "Announced",
          "args": [
            "AccountId",
            "AccountId",
            "Hash"
          ],
          "docs": [
            " An announcement was placed to make a call in the future. [real, proxy, call_hash]"
          ],
          "look_up": "1e02"
        }
      ],
      "errors": [
        {
          "name": "TooMany",
          "docs": [
            " There are too many proxies registered or too many announcements pending."
          ]
        },
        {
          "name": "NotFound",
          "docs": [
            " Proxy registration not found."
          ]
        },
        {
          "name": "NotProxy",
          "docs": [
            " Sender is not a proxy of the account to be proxied."
          ]
        },
        {
          "name": "Unproxyable",
          "docs": [
            " A call which is incompatible with the proxy type's filter was attempted."
          ]
        },
        {
          "name": "Duplicate",
          "docs": [
            " Account is already a proxy."
          ]
        },
        {
          "name": "NoPermission",
          "docs": [
            " Call may not be made by proxy because it may escalate its privileges."
          ]
        },
        {
          "name": "Unannounced",
          "docs": [
            " Announcement, if made at all, was made too recently."
          ]
        }
      ],
      "constants": [
        {
          "name": "ProxyDepositBase",
          "type": "BalanceOf<T>",
          "value": "00f09e544c3900000000000000000000",
          "docs": [
            " The base amount of currency needed to reserve for creating a proxy."
          ]
        },
        {
          "name": "ProxyDepositFactor",
          "type": "BalanceOf<T>",
          "value": "0060aa7714b400000000000000000000",
          "docs": [
            " The amount of currency needed per proxy added."
          ]
        },
        {
          "name": "MaxProxies",
          "type": "u16",
          "value": "2000",
          "docs": [
            " The maximum amount of proxies allowed for a single account."
          ]
        },
        {
          "name": "MaxPending",
          "type": "u32",
          "value": "20000000",
          "docs": [
            " `MaxPending` metadata shadow."
          ]
        },
        {
          "name": "AnnouncementDepositBase",
          "type": "BalanceOf<T>",
          "value": "00f09e544c3900000000000000000000",
          "docs": [
            " `AnnouncementDepositBase` metadata shadow."
          ]
        },
        {
          "name": "AnnouncementDepositFactor",
          "type": "BalanceOf<T>",
          "value": "00c054ef286801000000000000000000",
          "docs": [
            " `AnnouncementDepositFactor` metadata shadow."
          ]
        }
      ],
      "index": 30
    },
    {
      "name": "Multisig",
      "prefix": "Multisig",
      "calls": [
        {
          "name": "as_multi_threshold_1",
          "args": [
            {
              "name": "other_signatories",
              "type": "Vec<T::AccountId>"
            },
            {
              "name": "call",
              "type": "Box<<T as Trait>::Call>"
            }
          ],
          "docs": [
            " Immediately dispatch a multi-signature call using a single approval from the caller.",
            "",
            " The dispatch origin for this call must be _Signed_.",
            "",
            " - `other_signatories`: The accounts (other than the sender) who are part of the",
            " multi-signature, but do not participate in the approval process.",
            " - `call`: The call to be executed.",
            "",
            " Result is equivalent to the dispatched result.",
            "",
            " # <weight>",
            " O(Z + C) where Z is the length of the call and C its execution weight.",
            " -------------------------------",
            " - Base Weight: 33.72 + 0.002 * Z \u00b5s",
            " - DB Weight: None",
            " - Plus Call Weight",
            " # <\/weight>"
          ],
          "look_up": "1f00"
        },
        {
          "name": "as_multi",
          "args": [
            {
              "name": "threshold",
              "type": "u16"
            },
            {
              "name": "other_signatories",
              "type": "Vec<T::AccountId>"
            },
            {
              "name": "maybe_timepoint",
              "type": "Option<Timepoint<T::BlockNumber>>"
            },
            {
              "name": "call",
              "type": "OpaqueCall"
            },
            {
              "name": "store_call",
              "type": "bool"
            },
            {
              "name": "max_weight",
              "type": "Weight"
            }
          ],
          "docs": [
            " Register approval for a dispatch to be made from a deterministic composite account if",
            " approved by a total of `threshold - 1` of `other_signatories`.",
            "",
            " If there are enough, then dispatch the call.",
            "",
            " Payment: `DepositBase` will be reserved if this is the first approval, plus",
            " `threshold` times `DepositFactor`. It is returned once this dispatch happens or",
            " is cancelled.",
            "",
            " The dispatch origin for this call must be _Signed_.",
            "",
            " - `threshold`: The total number of approvals for this dispatch before it is executed.",
            " - `other_signatories`: The accounts (other than the sender) who can approve this",
            " dispatch. May not be empty.",
            " - `maybe_timepoint`: If this is the first approval, then this must be `None`. If it is",
            " not the first approval, then it must be `Some`, with the timepoint (block number and",
            " transaction index) of the first approval transaction.",
            " - `call`: The call to be executed.",
            "",
            " NOTE: Unless this is the final approval, you will generally want to use",
            " `approve_as_multi` instead, since it only requires a hash of the call.",
            "",
            " Result is equivalent to the dispatched result if `threshold` is exactly `1`. Otherwise",
            " on success, result is `Ok` and the result from the interior call, if it was executed,",
            " may be found in the deposited `MultisigExecuted` event.",
            "",
            " # <weight>",
            " - `O(S + Z + Call)`.",
            " - Up to one balance-reserve or unreserve operation.",
            " - One passthrough operation, one insert, both `O(S)` where `S` is the number of",
            "   signatories. `S` is capped by `MaxSignatories`, with weight being proportional.",
            " - One call encode & hash, both of complexity `O(Z)` where `Z` is tx-len.",
            " - One encode & hash, both of complexity `O(S)`.",
            " - Up to one binary search and insert (`O(logS + S)`).",
            " - I\/O: 1 read `O(S)`, up to 1 mutate `O(S)`. Up to one remove.",
            " - One event.",
            " - The weight of the `call`.",
            " - Storage: inserts one item, value size bounded by `MaxSignatories`, with a",
            "   deposit taken for its lifetime of",
            "   `DepositBase + threshold * DepositFactor`.",
            " -------------------------------",
            " - Base Weight:",
            "     - Create:          41.89 + 0.118 * S + .002 * Z \u00b5s",
            "     - Create w\/ Store: 53.57 + 0.119 * S + .003 * Z \u00b5s",
            "     - Approve:         31.39 + 0.136 * S + .002 * Z \u00b5s",
            "     - Complete:        39.94 + 0.26  * S + .002 * Z \u00b5s",
            " - DB Weight:",
            "     - Reads: Multisig Storage, [Caller Account], Calls (if `store_call`)",
            "     - Writes: Multisig Storage, [Caller Account], Calls (if `store_call`)",
            " - Plus Call Weight",
            " # <\/weight>"
          ],
          "look_up": "1f01"
        },
        {
          "name": "approve_as_multi",
          "args": [
            {
              "name": "threshold",
              "type": "u16"
            },
            {
              "name": "other_signatories",
              "type": "Vec<T::AccountId>"
            },
            {
              "name": "maybe_timepoint",
              "type": "Option<Timepoint<T::BlockNumber>>"
            },
            {
              "name": "call_hash",
              "type": "[u8; 32]"
            },
            {
              "name": "max_weight",
              "type": "Weight"
            }
          ],
          "docs": [
            " Register approval for a dispatch to be made from a deterministic composite account if",
            " approved by a total of `threshold - 1` of `other_signatories`.",
            "",
            " Payment: `DepositBase` will be reserved if this is the first approval, plus",
            " `threshold` times `DepositFactor`. It is returned once this dispatch happens or",
            " is cancelled.",
            "",
            " The dispatch origin for this call must be _Signed_.",
            "",
            " - `threshold`: The total number of approvals for this dispatch before it is executed.",
            " - `other_signatories`: The accounts (other than the sender) who can approve this",
            " dispatch. May not be empty.",
            " - `maybe_timepoint`: If this is the first approval, then this must be `None`. If it is",
            " not the first approval, then it must be `Some`, with the timepoint (block number and",
            " transaction index) of the first approval transaction.",
            " - `call_hash`: The hash of the call to be executed.",
            "",
            " NOTE: If this is the final approval, you will want to use `as_multi` instead.",
            "",
            " # <weight>",
            " - `O(S)`.",
            " - Up to one balance-reserve or unreserve operation.",
            " - One passthrough operation, one insert, both `O(S)` where `S` is the number of",
            "   signatories. `S` is capped by `MaxSignatories`, with weight being proportional.",
            " - One encode & hash, both of complexity `O(S)`.",
            " - Up to one binary search and insert (`O(logS + S)`).",
            " - I\/O: 1 read `O(S)`, up to 1 mutate `O(S)`. Up to one remove.",
            " - One event.",
            " - Storage: inserts one item, value size bounded by `MaxSignatories`, with a",
            "   deposit taken for its lifetime of",
            "   `DepositBase + threshold * DepositFactor`.",
            " ----------------------------------",
            " - Base Weight:",
            "     - Create: 44.71 + 0.088 * S",
            "     - Approve: 31.48 + 0.116 * S",
            " - DB Weight:",
            "     - Read: Multisig Storage, [Caller Account]",
            "     - Write: Multisig Storage, [Caller Account]",
            " # <\/weight>"
          ],
          "look_up": "1f02"
        },
        {
          "name": "cancel_as_multi",
          "args": [
            {
              "name": "threshold",
              "type": "u16"
            },
            {
              "name": "other_signatories",
              "type": "Vec<T::AccountId>"
            },
            {
              "name": "timepoint",
              "type": "Timepoint<T::BlockNumber>"
            },
            {
              "name": "call_hash",
              "type": "[u8; 32]"
            }
          ],
          "docs": [
            " Cancel a pre-existing, on-going multisig transaction. Any deposit reserved previously",
            " for this operation will be unreserved on success.",
            "",
            " The dispatch origin for this call must be _Signed_.",
            "",
            " - `threshold`: The total number of approvals for this dispatch before it is executed.",
            " - `other_signatories`: The accounts (other than the sender) who can approve this",
            " dispatch. May not be empty.",
            " - `timepoint`: The timepoint (block number and transaction index) of the first approval",
            " transaction for this dispatch.",
            " - `call_hash`: The hash of the call to be executed.",
            "",
            " # <weight>",
            " - `O(S)`.",
            " - Up to one balance-reserve or unreserve operation.",
            " - One passthrough operation, one insert, both `O(S)` where `S` is the number of",
            "   signatories. `S` is capped by `MaxSignatories`, with weight being proportional.",
            " - One encode & hash, both of complexity `O(S)`.",
            " - One event.",
            " - I\/O: 1 read `O(S)`, one remove.",
            " - Storage: removes one item.",
            " ----------------------------------",
            " - Base Weight: 36.07 + 0.124 * S",
            " - DB Weight:",
            "     - Read: Multisig Storage, [Caller Account], Refund Account, Calls",
            "     - Write: Multisig Storage, [Caller Account], Refund Account, Calls",
            " # <\/weight>"
          ],
          "look_up": "1f03"
        }
      ],
      "events": [
        {
          "name": "NewMultisig",
          "args": [
            "AccountId",
            "AccountId",
            "CallHash"
          ],
          "docs": [
            " A new multisig operation has begun. [approving, multisig, call_hash]"
          ],
          "look_up": "1f00"
        },
        {
          "name": "MultisigApproval",
          "args": [
            "AccountId",
            "Timepoint<BlockNumber>",
            "AccountId",
            "CallHash"
          ],
          "docs": [
            " A multisig operation has been approved by someone. [approving, timepoint, multisig, call_hash]"
          ],
          "look_up": "1f01"
        },
        {
          "name": "MultisigExecuted",
          "args": [
            "AccountId",
            "Timepoint<BlockNumber>",
            "AccountId",
            "CallHash",
            "DispatchResult"
          ],
          "docs": [
            " A multisig operation has been executed. [approving, timepoint, multisig, call_hash]"
          ],
          "look_up": "1f02"
        },
        {
          "name": "MultisigCancelled",
          "args": [
            "AccountId",
            "Timepoint<BlockNumber>",
            "AccountId",
            "CallHash"
          ],
          "docs": [
            " A multisig operation has been cancelled. [cancelling, timepoint, multisig, call_hash]"
          ],
          "look_up": "1f03"
        }
      ],
      "errors": [
        {
          "name": "MinimumThreshold",
          "docs": [
            " Threshold must be 2 or greater."
          ]
        },
        {
          "name": "AlreadyApproved",
          "docs": [
            " Call is already approved by this signatory."
          ]
        },
        {
          "name": "NoApprovalsNeeded",
          "docs": [
            " Call doesn't need any (more) approvals."
          ]
        },
        {
          "name": "TooFewSignatories",
          "docs": [
            " There are too few signatories in the list."
          ]
        },
        {
          "name": "TooManySignatories",
          "docs": [
            " There are too many signatories in the list."
          ]
        },
        {
          "name": "SignatoriesOutOfOrder",
          "docs": [
            " The signatories were provided out of order; they should be ordered."
          ]
        },
        {
          "name": "SenderInSignatories",
          "docs": [
            " The sender was contained in the other signatories; it shouldn't be."
          ]
        },
        {
          "name": "NotFound",
          "docs": [
            " Multisig operation not found when attempting to cancel."
          ]
        },
        {
          "name": "NotOwner",
          "docs": [
            " Only the account that originally created the multisig is able to cancel it."
          ]
        },
        {
          "name": "NoTimepoint",
          "docs": [
            " No timepoint was given, yet the multisig operation is already underway."
          ]
        },
        {
          "name": "WrongTimepoint",
          "docs": [
            " A different timepoint was given to the multisig operation that is underway."
          ]
        },
        {
          "name": "UnexpectedTimepoint",
          "docs": [
            " A timepoint was given, yet no multisig operation is underway."
          ]
        },
        {
          "name": "WeightTooLow",
          "docs": [
            " The maximum weight information provided was too low."
          ]
        },
        {
          "name": "AlreadyStored",
          "docs": [
            " The data to be stored is already stored."
          ]
        }
      ],
      "constants": [
        {
          "name": "DepositBase",
          "type": "BalanceOf<T>",
          "value": "00f01c0adbed01000000000000000000",
          "docs": [
            " The base amount of currency needed to reserve for creating a multisig execution or to store",
            " a dispatch call for later."
          ]
        },
        {
          "name": "DepositFactor",
          "type": "BalanceOf<T>",
          "value": "0000cc7b9fae00000000000000000000",
          "docs": [
            " The amount of currency needed per unit threshold when creating a multisig execution."
          ]
        },
        {
          "name": "MaxSignatories",
          "type": "u16",
          "value": "6400",
          "docs": [
            " The maximum amount of signatories allowed for a given multisig."
          ]
        }
      ],
      "index": 31
    }
  ],
  "extrinsic": {
    "version": 4,
    "signedExtensions": [
      "CheckSpecVersion",
      "CheckTxVersion",
      "CheckGenesis",
      "CheckMortality",
      "CheckNonce",
      "CheckWeight",
      "ChargeTransactionPayment"
    ]
  },
  "metadata_version": 12
}